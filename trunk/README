This is the README file for gmp-ecm. (See README.lib for the ecm library.)

Table of contents of this file:
1. Files included in this distribution.
2. How to efficiently use P-1, P+1 and ECM?
3. Extra factors and Brent-Suyama's extension.
4. Memory usage.
5. Expression syntax reference for gmp-ecm's syntax parser.
6. Options -save and -resume.
7. working with very large numbers (the -prp* options)
8. How to get the best of gmp-ecm?
9. Known problems.
10. Record factors.

##############################################################################

1. Files included in this distribution.

aclocal.m4   - configuration file
AUTHORS      - program authors
*.c          - C source files
COPYING      - GNU General Public License
COPYING.LIB  - GNU Lesser General Public License
ChangeLog    - changes with respect to previous versions
config*      - configuration files
depcomp      - configuration file
ecm.1        - man page
*.h          - header files
INSTALL      - instructions to compile and install gmp-ecm
install-sh   - installation file
Makefile*    - to build the binary file
missing      - configuration file
NEWS         - news file
README       - this file
test.*       - test files
TODO         - to-do list

##############################################################################

2. How to efficiently use P-1, P+1 and ECM?

The P-1 method works well when the input number has a prime factor P such
that P-1 is "smooth", i.e. has all its prime factor less or equal the 
step 1 bound B1, except one which may be less or equal the second step
bound B2. For P=67872792749091946529, we have P-1 = 2^5 * 11 * 17 * 19 *
43 * 149 * 8467 * 11004397, so this factor will be found as long as B1 >= 8467
and B2 >= 11004397:

$ echo 67872792749091946529 | ./ecm -pm1 -x0 2809890345 8467 11004397
GMP-ECM 5.2.0 [powered by GMP 4.1.4] [P-1]
Input number is 67872792749091946529 (20 digits)
Using B1=8467, B2=11004397, polynomial Dickson(6), x0=2809890345
Step 1 took 5ms
Step 2 took 278ms
********** Factor found in step 2: 67872792749091946529
Found input number N

There is no need to run several times P-1 with the same B1 and B2, like
for ECM, since a factor found with one seed will be found by another one.

The P+1 method works well when the input number has a prime factor P such
that P+1 is "smooth". For P=4190453151940208656715582382315221647, we have
P+1 = 2^4 * 283 * 2423 * 21881 * 39839 * 1414261 * 2337233 * 132554351, so
this factor will be found as long as B1 >= 2337233 and B2 >= 132554351:

$ echo 4190453151940208656715582382315221647 | ./ecm -pp1 -x0 2284918860 2337233 132554351
GMP-ECM 5.2.0 [powered by GMP 4.1.4] [P+1]
Input number is 4190453151940208656715582382315221647 (37 digits)
Using B1=2337233, B2=132554351, polynomial x^1, x0=2284918860
Step 1 took 2912ms
Step 2 took 1776ms
********** Factor found in step 2: 4190453151940208656715582382315221647
Found input number N

However not all seeds will succeed: only half of the seeds 's' work for P+1
(namely those where the Jacobi symbol of s^2-4 and P is -1.) Unfortunately, 
since P is usually not known in advance, there is no way to ensure that this 
holds. However, if the seed is chosen randomly, there is a probability of 
about 1/2 that it will give a Jacobi symbol of -1 (i.e. the factor P will 
be found if P+1 is smooth enough). A rule of thumb is to run 3 times P+1 
with different random seeds.

The ECM method is a probabilistic method, and can be viewed in some sense
as a generalization of the P-1 and P+1 method, where we only require that
P+t is smooth, with t random of order P^(1/2). The optimal B1 and B2 bounds
have to be chosen according to the (usually unknown) size of P. The following
table gives a set of near-to-optimal B1 and B2 pairs, with the corresponding
expected number of curves to find a factor of given size (column "-power 1"
does not take into account the extra factors found by Brent-Suyama's extension,
whereas column "default poly" takes them into account, with the polynomial used
by default: D(n) means Dickson's polynomial of degree n):

       digits D  optimal B1      B2                expected curves
                                                       N(B1,B2,D)
                                              -power 1         default poly
          20       11e3         1.7e6             89               89 [x^1]
          25        5e4         1.5e7            244              237 [x^2]
          30       25e4         1.2e8            526              499 [D(3)]
          35        1e6         9.7e8           1132             1044 [D(6)]
          40        3e6         4.5e9           2992             2691 [D(12)]
          45       11e6        3.0e10           5706             5166 [D(12)]
          50       43e6        1.9e11           9507             8370 [D(30)]
          55       11e7        7.2e11          22605            19977 [D(30)]
          60       26e7        2.4e12          54580            48478 [D(30)]
          65       85e7        1.5e13          85729            76396 [D(30)]

          Table 1: optimal B1 and expected number of curves to find a
          factor of D digits with gmp-ecm.

After performing the expected number of curves from Table 1, the
probability that a factor of D digits was missed is exp(-1), i.e.
about 37%. After twice the expected number of curves, it is exp(-2),
i.e. about 14%, and so on.

Example: after performing 9507 curves with B1=43e6 and B2=1.9e11
(or 8370 curves with -dickson 30), the probability to miss a 50-digit
factor is about 37%.

In summary, we advise the following method:

0 - choose a target factor size of D digits
1 - choose optimal B1 and B2 values to find factors of D digits (cf Table 1)
2 - run once P-1 with that B1, and the default B2 chosen by gmp-ecm
3 - run 3 times P+1 with that B1, and the default B2 chosen by gmp-ecm
4 - run N(B1,B2,D) times ECM with those B1 and B2, where N(B1,B2,D) is the
    expected number of ECM curves with step 1 bound B1, step 2 bound B2,
    to find a factor of D digits (cf above table). 
5 - if no factor is found, either increase D and go to 0, or use another
    factorization method (MPQS, GNFS)

Note: if a factor is found in steps 2, 3 or 4, simply continue the current
      step with the remaining cofactor (if composite). There is no need
      to start again from 0, since the cofactor got the ecm effort too.

##############################################################################

3. Extra factors and Brent-Suyama's extension.

GMP-ECM may sometimes find some "extra" factors, such that one factor of P-1, 
P+1 or P+t exceeds the step 2 bound B2, thanks to Brent-Suyama's extension. 
Let's explain how it works for P-1, since it's simpler. The classical step 2 
(without Brent-Suyama's extension) considers s^(j*d) mod N and s^i mod N, 
where N is the number to factor, and s is the residue computed in stage 1. 
Here, d is fixed, and the integers i and j vary in two sets so that j*d-i 
covers all primes in [B1, B2]. Now consider a polynomial f(x), and compute 
s^f(j*d) and s^f(i) instead of s^(j*d) and s^i [thus the classical step 2 
corresponds to f(x)=x^1]. Then P will be found whenever all but one of the 
factors of P-1 are <= B1, and one factor divides some f(j*d) - f(i):

$ echo 1207946164033269799036708918081 | ./ecm -pm1 -k 3 -power 12 286493 25e6
GMP-ECM 5.2.0 [powered by GMP 4.1.4] [P-1]
Input number is 1207946164033269799036708918081 (31 digits)
Using B1=286493, B2=25000000, polynomial x^12, x0=2645739889
Step 1 took 238ms
Step 2 took 461ms
********** Factor found in step 2: 1207946164033269799036708918081
Found input number N

Here the largest factor of P-1 is 83957197, which is 3.35 times larger than B2.
Warning: these "extra" factorizations may not be reproducible from one
version of gmp-ecm to another one, since they depend on some internal
parameters that may change.

For P-1, the degree of the Brent-Suyama polynomial should be even. Since
i^2k - (j*d)^2k = (i^k - (j*d)^k)(i^k + (j*d)^k), this allows testing two
values symmetric around a multiple of d simultaneously, halving the amount of
computation required in stage 2. P+1 and ECM do this inherently.

The default polynomial used for a given B2 should be near optimal, 
i.e. give only a marginal overhead in step 2, while enabling extra factors.

##############################################################################

4. Memory usage.

Step 1 does not require much memory (about the same size as
the input number). Step 2 may be quite memory expensive, especially for
large B2, since its efficient algorithms use some large tables. To reduce
the memory usage of step 2, you may increase the 'k' parameter, which controls
the number of "blocks" performed in step 2. Multiplying the default value of
k by 4 will decrease the memory usage by 2. For example with B2=1e10 and
a 155-digit number, step 2 requires about 96MB with the default k=2,
but only 42MB with k=8. Increasing k does, however, slightly increase the
time required for step 2 (see section "How to get the best of gmp-ecm?")

NOTE that in -b "breadth-first" mode, gmp-ecm reads all candidate numbers in 
the input stream and keeps them in memory, so if there are many large numbers
to be tested, the memory requirement will increase noticeably.

##############################################################################

5. Expression syntax reference for gmp-ecm's syntax parser.

Up from release 5.2.0, GMP-ECM can handle several kinds of expressions
as input numbers. Here is the syntax that is handled:

1.  Raw decimal numbers (as in previous versions) like 123456789
2.  Comments can be placed in the file.  The C++ "one line comment"  // 
    is used.  Everything after the // on a line (including the //) is ignored.
    Warning: no input number should appear on such a comment line.
3.  Line continuation. If a line ends with a backslash character '\',
    it is considered it continues on the next line (ignoring the '\').
4.  Any white space (space, tab, end of line) is ignored.  However, the "end of
    line" is used to end the expression (unless of course there is a '\' 
    character before the end of line).  For example, processing this:
    1 2 3 4 5 6 7 8 9
    would be the same as processing
    123456789
5.  "common" arithmetic expressions ( * / + - % )  period . can also be used in
    place of * for multiply, and - can be unary minus (i.e.  -55555551).
    Example: echo "3*5+2" | ./ecm 100
6.  Grouping  ( [ { for start of group (which symbol is used does not matter)
    and ) ] } to end a group (again all 3 symbols mean the SAME thing).
7.  Exponentiation with the ^ character  (i.e.  2^24 is the same as 16777216).
    Example: echo "2^24+1" | ./ecm 100
8.  Simple factorial using the exclamation point !  character.  Example is
    53! == 1*2*3*4...*52*53. Example: echo '53!+1' | ./ecm 1e2
9.  Multi-factorial as in: n!m with an example:  15!3 == 15.12.9.6.3.
10. Simple Primorial using the # character  with example of 11# == 2*3*5*7*11
11. Reduced Primorial   n#m  with example of 17#5 == 5.7.11.13.17
12. Functions are possible with the expression parser. Currently, the only 
    available function is Phi(x,n), however other functions should be easy
    to add in the future.

Note: Expressions are maintained as much as possible (even if the expression
becomes longer than the decimal expansion). Expressions are output as cofactors
(if the input was an expression), and are stored into save/resume files
(again if and only if the original input was an expression, and not a expanded
decimal number). When a factor is found, the cofactor expression is of the
form (original_expression)/factor_found (see however option -cofdec):

$ echo "3*2^210+1" | ./ecm -sigma 4007218240 2500
GMP-ECM 5.2.0 [powered by GMP 4.1.4] [ECM]
Input number is 3*2^210+1 (64 digits)
Using B1=2500, B2=164648, polynomial x^1, sigma=4007218240
Step 1 took 23ms
Step 2 took 20ms
********** Factor found in step 2: 1358437
Found probable prime factor of  7 digits: 1358437
Probable prime cofactor (3*2^210+1)/1358437 has 58 digits

##############################################################################

6. Options -save and -resume.

These options are useful to save the current state of the computation after
step 1, or to exchange data with other software. It allows to perform
step 1 with gmp-ecm, and step 2 with another software (or vice-versa).

Here is an example how to reuse some P-1 computation:

$ cat c71
13155161912808540373988986448257115022677318870175067553764004308210487
$ ./ecm -save toto -pm1 -mpzmod -x0 2 5000000 < c71
GMP-ECM 5.2.0 [powered by GMP 4.1.4] [P-1]
Input number is 13155161912808540373988986448257115022677318870175067553764004308210487 (71 digits)
Using B1=5000000, B2=272993793, polynomial x^24, x0=2
Step 1 took 5149ms
Step 2 took 3523ms

The file "toto" now contains some information about the method used, the step
1 bound, the number to factor, the value X at the end of step 1 (in hexa-
decimal), and a checksum to verify that no data was corrupted:

$ cat toto
METHOD=P-1; B1=5000000; N=13155161912808540373988986448257115022677318870175067553764004308210487; X=0x12530157ae22ae14d54d6a5bc404ae9458e54032c1bb2ab269837d1519f; CHECKSUM=2287710189; PROGRAM=GMP-ECM 5.2.0; X0=0x2; WHO=zimmerma@localhost.localdomain; TIME=Wed Jan 26 21:09:49 2005;

Then one can resume the computation with larger B1 and/or B2 as follows:

$ ./ecm -resume toto 1e7
GMP-ECM 5.2.0 [powered by GMP 4.1.4] [ECM]
Resuming P-1 residue saved by zimmerma@localhost.localdomain with GMP-ECM 5.2.0 on Wed Jan 26 21:09:49 2005 
Input number is 13155161912808540373988986448257115022677318870175067553764004308210487 (71 digits)
Using B1=5000000-10000000, B2=732940912, polynomial x^24
Step 1 took 5091ms
Step 2 took 5805ms
********** Factor found in step 2: 1448595612076564044790098185437
Found probable prime factor of 31 digits: 1448595612076564044790098185437
Probable prime cofactor 9081321110693270343633073697474256143651 has 40 digits

The second run only considered the primes in [5e6-10e6] in step 1,
which saved half the time of step 1.

The format used is the following:
  - each line corresponds to a composite (expression ARE saved in the save file)
  - a line contains assignments <id>=<value> separated by semi-colons ';'
  - possible values for <id> are 
    - METHOD (value = ECM or P-1 or P+1)
    - SIGMA (value = ECM sigma parameter) [optional]
    - B1 (first step bound)
    - N (composite to factor)
    - X (value at the end of step 1)
    - A (A-parameter of the elliptic curve)
    - CHECKSUM (internal value to check correctness of the format)
    - PROGRAM (program used to perform step 1, useful for factor credits) 
    - X0 (initial point for ECM, or initial residue for P-1/P+1) [optional]
    - WHO (who performed step 1) 
    - TIME (date and time of first step)
  SIGMA and X0 would be optional, and would be mainly be used in case of a
  factor is found, to be able to reproduce the factorization.
  For ECM, one of the SIGMA or A values must be present, so that the
  computation can be continued on the correct curve.

Note: it is allowed to have both -save f1 and -resume f2 for the same run,
however the files f1 and f2 should be different.

Remark: you should not perform in parallel several -resume runs on the same
input with the same B1/B2 values, since those runs will do the same 
computations. Options -save/-resume is useful in the following cases:

(a) somebody did a previous step 1 computation with another software
    which is faster than gmp-ecm, and wants to perform Step 2 with
    gmp-ecm which is faster for that task.
(b) somebody did a previous step 1 for P-1 or P+1 up to a given bound
    B1, and you want to extend that computation with B1' > B1, without
    restarting from scratch. Note: this does not apply to ECM, where 
    the smoothness property depends on the (random) curve chosen, not
    on the input number.
(c) you did a huge step 1 P-1 or P+1 computation on a given machine, and you
    want to perform a huge step 2 in parallel on several
    machines. For example machine 1 tests the range B2_1-B2_2, machine
    2 tests B2_2-B2_3, ... This also decreases the memory usage for
    each machine, which is function of the range width B2min-B2max.
    For the same reason as (b), this does not apply to ECM. 

##############################################################################

7. Working with very large numbers (the -prp* options)

When working with very large numbers, probable-primality testing becomes
very slow when using GMP.  A faster program is available: OpenPFGW (pfgw).
pfgw only does a simple Fermat test, but is much faster, due to it's highly 
optimal FFT multiplication code.  The difference at 15k digits is about 10
minutes for GMP, and about 20s for PFGW (and the difference only gets more
severe).  A limitation of OpenPFGW, is it will only be a viable solution for
Intel 32 bit CPU's, as the FFT code is only built for those systems.

##############################################################################

8. How to get the best of gmp-ecm?

Choice of modular multiplication. The ecm program may choose between 4 kinds
of modular arithmetic:

(1) Montgomery's REDC algorithm at the word level (option -modmuln).
    It is quite fast for small numbers, but has quadratic asymptotic
    complexity.
(2) classical GMP arithmetic (option -mpzmod).
    Has some overhead with respect to (1) for small sizes, but wins
    over (1) for larger sizes since it has quasi-linear asymptotic
    complexity.
(3) Montgomery's REDC algorithm at high level (option -redc).
    This essentially replaces each division by two multiplications.
    Slower than (1) and (2) for small inputs, but better for large
    or very large inputs.
(4) base-2 arithmetic for numbers dividing 2^n+1 or 2^n-1.
    Each division has only linear time, but the multiplication are
    most expensive since they are done on larger numbers.

The ecm program automatically selects what he thinks is the best
arithmetic for the given input number. If that choice is not optimal, you may 
force the use of a certain arithmetic by trying options -modmulm, -mpzmod, 
-redc. (The best choice should depend on B1 and B2 only very little, so long 
as B1 is not too small, say >= 1000.)

The "tune" program helps you to determine the optimal threshold for
your computer. After compiling it with "make tune", type "./tune"
and it will display timings for each method (mpzmod, modmuln, redc)
for numbers of limbs equal to 1, 2, 3, ... When the best thresholds
can be determined, the program stops and displays their values. Then
simply (re)compile ecm, adding -DMPZMOD_THRESHOLD=xxx -DREDC_THRESHOLD=yyy
in CFLAGS.

Number of step 2 blocks. The step 2 range [B1,B2] is divided into k 
"big blocks". The default value of k is chosen to be near to optimal.
However, it may be that for a given (B1,B2) pair, another value of k
may be better. Try for this to give the option -k <value> to ecm,
where <value> is 1, 2, 3, ... This will force ecm to divide step 2
in at least <value> blocks.

Changing the value of the number of blocks will not modify the chance
of finding a factor (except for extra factors, but some will be lost,
and some will be won, so the balance should be even). However it will
increase the time spent in Step 2 (when less or greater than the
optimal value), and modify the memory used by Step 2 (see the section 
"Memory usage").

Optimal gmp thresholds. One may improve the performance of gmp-ecm
by telling the thresholds used by GMP for Karatsuba's multiplication
and divide-and-conquer division, which you can get by typing:

$ egrep 'MUL_KARATSUBA_THRESHOLD|DIV_DC_THRESHOLD' gmp-mparam.h

in the GMP build directory. You can override the default values
(32 for MUL_KARATSUBA_THRESHOLD, and 96 for DIV_DC_THRESHOLD)
by adding -DMUL_KARATSUBA_THRESHOLD=... -DDIV_DC_THRESHOLD=...
to the CFLAGS.

Note on factoring Fermat numbers:
gmp-ecm features Sch"onhage-Strassen multiplication for polynomials in 
stage 2 when factoring Fermat numbers. This greatly reduces the number of 
modular multiplications required, thus improving speed. It does, however, 
restrict the length of the polynomials to powers of two, so that for a given 
number of blocks (-k parameter), the B2 value can only increase by factors of 
approximately 4.
For the number of blocks, choices of 1, 2 or 3 usually give best performance.
However, if the polynomial degree becomes too large, relatively expensive
Karatsuba or Toom-Coom methods are required to split the polynomial before
Sch"onhage-Strassen's method can handle them. That can make a larger number 
of blocks worthwhile. When factoring the m-th Fermat number F_m = 2^(2^m)+1,
degrees up to dF=2^(m+1) can be handled directly. If your B2 choice
requires a degree much larger than this (dF is printed with the -v
parameter), try increasing the number of blocks with -k and see if
performance improves.
The Brent-Suyama extension should not be used when factoring Fermat numbers,
it is more efficient to simply increase B2. You should always use parameters
-power 1 for ECM, or -power 2 for P-1.
Factoring Fermat numbers uses a lot of memory, depending on the size of the
Fermat number and on dF. The amount of data kept in memory in stage 2 is
approximately dF*(log_2(dF)+6) residues. For dF=65536 and F_12, this means
704 MB. If your system does not have enough memory, you will have to use a
larger number of blocks to reach the desired B2 value with a smaller poly
degree dF, which sacrifices some performance.

                k=1             k=2             k=3             k=4

dF=256          630630          1261260         1921920         2552550
dF=512          2522520         5105100         7687680         10210200
dF=1024         10210200        20420400        30750720        40960920
dF=2048         42882840        85975890        129068940       172161990
dF=4096         174083910       348167820       522762240       696846150
dF=8192         713242530       1426485060      2139727590      2852970120
dF=16384        2852970120      5705940240      8560652100      11413622220
dF=32768        11707015320     23417604210     35128193100     46838781990
dF=65536        48094126080     96188252160     144282378240    192376504320
dF=131072       194046382530    388092765060    582139147590    776185530120

                Table 2: Stage 2 interval length B2-B2min, for dF
                a power of 2 and small values of k.

For example, if you'd like to run stage 2 on F_12 with B2 ~= 40G, try
parameters "-power 1 -k 1 <B1> 48e9", "-power 1 -k 3 <B1> 35e9" or 
"-power 1 -k 4 <B1> 46e9".

##############################################################################

9. Known problems.

(a) Under some operating systems (in particular Windows), ecm may use the
same random seed for several curves started during the same second. 
This is due to the fact that the getpid() function returns a constant
value under those systems. This will cause an efficiency loss, since
the same computation will be done twice. A workaround is to wait at
least one second between different curves on the same number, or to
specify by hand a different seed using the -sigma or -x0 options.
In all cases, when running several curves on the same number, it is
safe to check that the sigma/x0 values are different for each run.

(b) Under some operating systems (for example FreeBSD), you may have
to comment the #include <alloca.h> line in ecm-gmp.h.

(c) stderr output was mixed with stdout output.  This allows redirection
of output to a file, with ecm-gmp giving a VERY useful single line, listing
many good statistics of what is happening (current line of the file, current
"curve" count and total curve count to do, number of factors found, current
B1 level, ...)  The output also looks fine if stdout is not redirected
(stdout overwrites the stderr information and "looks right").  However, 
there can be some "strangeness" in some screen output if the stdout is being
handled by an external process (i.e. something like tee).  Since ecm-gmp 
is sending data to the screen which was sent to stderr, yet ecm-gmp does
not write to the screen on it's stdout output (tee is getting that output
and IT is writing it to screen), then some of the written output (to 
screen only), can get slightly "messed up" (out of order screen drawing.
There currently is no work around for this if using something like tee,
however, if you "do" want to "watch" the output to screen (while storing
it to file like you should be doing), then simply use absolute redirection
to a file, then use tail -f to "view" the outputted data.  The benefit
of this is that you get a VERY nice 1 line screen output, yet on a different
screen, can "see" the work as it is done, while still having the data
stored to disk (in case of power outage, or other catastophe).

(d) there may be "strangeness" caused by the writing to stderr. I can not 
fully comment on this due to my lack of usage of the  ecm client server (or
using ecm as:   "ecm options < in & nohup" (or whatever the syntax is for
running unnending in the background in *nix (Paul, please test how the
current version works under these conditions, then either update this 
known problem, or remove it if it is not a problem).
        
##############################################################################

10. Record factors.

If you find a very large factor, the program will print a message like:

Report your potential champion to <email address>
(see <url for record factors>)

This means that your factor might be a champion, i.e. one of the top-ten
largest factors ever found by the corresponding method (P-1, P+1 or ECM).
Cf the following URLs:

ECM: ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Richard.Brent/champs.txt
P-1: http://www.loria.fr/~zimmerma/records/Pminus1.html
P+1: http://www.loria.fr/~zimmerma/records/Pplus1.html
