This is a new version of gmp-ecm, replacing version 4c.
The contained files are:

COPYING - GNU GENERAL PUBLIC LICENSE
INSTALL - instructions to install gmp-ecm
Makefile - to build the binary file 'ecm5'
README - this file
auxi.c - auxiliary functions
bestd.c - routines to determine the best stage 2 parameters
c155 - test file containing a 155-digit composite
ecm.c - factorization routine using the Elliptic Curve Method
ecm.h - header file for gmp-ecm
ecm2.c - ECM stage 2 routines
getprime.c - dynamic Eratosthenes sieve
listz.c - arithmetic on lists of integers mod n
lucas.c - functions to evaluate Lucas sequences
main.c - main file for gmp-ecm, P-1 and P+1
memory.c - auxiliary routines to check memory allocation
mpmod.c - modular arithmetic
mul_lo.c - low-half short product
ntl.c - interface with NTL
pm1.c - Pollard P-1 factorization routine
polyeval.c - algorithm POLYEVAL
polyz.c - routines for polynomial arithmetic
pp1.c - P+1 factorization routines
resume.c - routines to resume a computation
stage2.c - common stage 2 implementation for ecm, P-1 and P+1
test.ecm - test file for ECM
test.pm1 - test file for P-1
test.pp1 - test file for P+1
toomcook.c - Toom-Cook 3 and Toom-Cook 4 multiplication
tune.c - auxiliary routines to compute optimal thresholds

The main changes wrt gmp-ecm 4c are the following:

- the code is split into several files to make the code easier to maintain
	and compile.
- the program now implements also P-1 and P+1, with a common stage 2
	(use option -pm1 to call P-1, -pp1 for P+1).
- stage 1 is about 10% faster, thanks to a new modular multiplication
  layer, and to a dynamic implementation of Eratosthenes sieve (getprime.c).
- stage 2 uses Toom-Cook 3 and Toom-Cook 4, instead of only Karatsuba
	in gmp-ecm 4c.
- an option -save enables one to save the state at the end of stage 1,
  to continue it afterwards, or on a different computer (with -resume).
- it is now possible to specify a range B2min-B2max for stage 2. This
  enables one to perform a huge stage 2 (for a given stage 1) using several 
  computers: the first one checks B1-B2, the second one B2-B3, ...

##############################################################################

How to efficiently use P-1, P+1 and ECM.

The P-1 method works well when the input number has a prime factor P such
that P-1 is "smooth", i.e. has all its prime factor less or equal the 
stage 1 bound B1, except one which may be less or equal the second stage
bound B2. For P=67872792749091946529, we have P-1 = 2^5 * 11 * 17 * 19 *
43 * 149 * 8467 * 11004397, so this factor will be found as long as B1 >= 8467
and B2 >= 11004397:

$ echo 67872792749091946529 | ./ecm -pm1 -x0 2809890345 8467 11004397
GMP-ECM 5.0-beta [powered by GMP 4.1.2]
Input number is 67872792749091946529 (20 digits)
Pollard P-1 Method with B1=8467, B2=11004397, x^2
Using seed=2809890345
Using MODMULN
Stage 1 took 10ms
Stage 2 took 330ms
********** Factor found in step 2: 67872792749091946529
Found input number N

There is no need to run several times P-1 with the same B1 and B2, like
for ECM, since a factor found with one seed will be found by another one.

The P+1 method works well when the input number has a prime factor P such
that P+1 is "smooth". For P=4190453151940208656715582382315221647, we have
P+1 = 2^4 * 283 * 2423 * 21881 * 39839 * 1414261 * 2337233 * 132554351, so
this factor will be found as long as B1 >= 2337233 and B2 >= 132554351:

$ echo 4190453151940208656715582382315221647 | ./ecm -pp1 -x0 2284918860 2337233 132554351
GMP-ECM 5.0-beta [powered by GMP 4.1.2]
Input number is 4190453151940208656715582382315221647 (37 digits)
Williams P+1 Method with B1=2337233, B2=132554351
Using seed=2284918860
Using MODMULN
Stage 1 took 3400ms
Stage 2 took 2470ms
********** Factor found in step 2:
4190453151940208656715582382315221647
Found input number N

However not all seeds will succeed: a given seed 's' works iff the Jacobi
symbol of s^2-4 and P is -1. Unfortunately, since P is usually not known
in advance, there is no way to ensure that this holds. However, if the
seed is chosen randomly, there is a probability of about 1/2 that it will
give a Jacobi symbol of -1 (i.e. the factor P will be found if it is smooth
enough). A rule of thumb is to run 3 times P+1 with different random seeds.

The ECM method is a probabilistic method, and can be viewed in some sense
as a generalization of the P-1 and P+1 method, where we only require that
P+t is smooth, with t random of order P^(1/2). The optimal B1 and B2 bounds
have to be chosen according to the (usually unknown) size of P. The following
table gives a set of near-to-optimal B1 and B2 pairs, with the corresponding
expected number of curves to find a factor of given size (this table does not
take into account the "extra factors" found by Brent-Suyama's extension, see
below).

       digits D  optimal B1      B2        expected curves N(B1,B2,D)
          15        2e3         1.2e5             30
          20       11e3         1.4e6             90
          25        5e4         1.2e7            240
          30       25e4         1.1e8            500
          35        1e6         8.4e8           1100
          40        3e6         4.0e9           2900
          45       11e6        2.6e10           5500
          50       43e6        1.8e11           9000
          55       11e7        6.8e11          22000
          60       26e7        2.3e12          52000
          65       85e7        1.3e13          83000
          70       29e8        7.2e13         120000

In summary, we advise the following method:

0 - choose a target factor size of D digits
1 - choose "optimal" B1 and B2 values to find factors of D digits
2 - run once P-1 with those B1 and B2
3 - run 3 times P+1 with those B1 and B2
4 - run N(B1,B2,D) times ECM with those B1 and B2, where N(B1,B2,D) is the
	expected number of ECM curves with stage 1 bound B1, stage 2 bound B2,
	to find a factor of D digits (cf above table)
5 - if no factor is found, either increase D and go to 0, or use another
	factorization method (MPQS, GNFS)

Note: if a factor is found in steps 2, 3 or 4, simply continue the current
	step with the remaining cofactor (if composite). There is no need
	to start again from 0, since the factorization effort on the cofactor
	is not lost.

Extra factors and Brent-Suyama's extension. GMP-ECM may sometimes find some
"extra" factors, such that one factor of P-1, P+1 or P+t exceeds the stage 2
bound B2, thanks to Brent-Suyama's extension. Let explain how it works for P-1,
since it's simpler. The classical stage 2 (without Brent-Suyama's extension)
considers s^(j*d) mod N and s^i mod N, where N is the number to factor, and
s the initial seed. Here, d is fixed, and the integers i and j vary in two
sets so that j*d+/-i covers all primes in [B1, B2]. Now consider a polynomial
f(x), and compute s^f(j*d) and s^f(i) instead of s^(j*d) and s^i [thus the
classical stage 2 corresponds to f(x)=x^1]. Then P will be found whenever
all but one of the factors of P-1 are <= B1, and one factor divides one
f(j*d) +/- f(i):

$ echo 1207946164033269799036708918081 | ./ecm -pm1 -k 4 -power 12 286493 25000000
GMP-ECM 5.0-beta [powered by GMP 4.1.2]
Input number is 1207946164033269799036708918081 (31 digits)
Pollard P-1 Method with B1=286493, B2=25000000, x^12
Using seed=2760000764
Using MODMULN
Stage 1 took 290ms
Stage 2 took 760ms
********** Factor found in step 2: 1207946164033269799036708918081
Found input number N

Here the largest factor of P-1 is 83957197, which is 3.35 times larger than B2.
Warning: these "extra" factorizations may not be reproducible in future
versions of gmp-ecm, since they depend on some internal parameters that
may change.

We have succesfully tested this version on the following configurations.
Here are some timings obtained with ECM (B1=3e6) on the following
155-digit number:

$ cat c155
95209938255048826235189575712705128366296557149606415206280987204268594538412191641776798249266895999715600261737863698825644292938050707507901970225804581

configuration          version   compiler      stage 1     stage 2
                       of gmp                  (seconds)   (seconds)
athlon-pc-linux-gnu   gmp-4.1.2 gcc-2.95.3       79.7       47.3 MP 2000+
alphaev6-dec-osf4.0f  gmp-4.1.2 gcc-2.95.3      106.0       84.4 EV6-500
pentium3-pc-linux-gnu gmp-4.1.2 gcc-2.95.3      411.2      214.4 PIII-500
mips64-sgi-irix6.5    gmp-4.1.2 gcc-3.0.1       401.3      251.0 R10K-250
powerpc630-ibm-aix5.1.0.0 4.1.2 xlc             337.5      155.0 Power3+ 375

##############################################################################

Memory usage. Stage 1 does not require much memory (about the same size as
the input number). Stage 2 may be quite memory expensive, especially for
large B2, since its efficient algorithms use some large tables. To reduce
the memory usage of stage 2, you may increase the 'k' parameter, which controls
the number of "blocks" performed in stage 2. Multiplying the default value of
k (which is 8) by 4 will decrease the memory usage by 2. For example with 
B2=1e10 and a 155-digit number, stage 2 requires about 28MB with the default
k, but only 14MB with k=32.

##############################################################################

Option -save. This option is useful to save the current stage in the P-1
method, or to exchange data with other software. It should allow to perform
stage 1 with gmp-ecm, and stage 2 with another software (or vice-versa).

Here is an example how to reuse some P-1 computation:

$ cat c71
13155161912808540373988986448257115022677318870175067553764004308210487
$ ./ecm -save toto -pm1 -mpzmod 5000000 < c71
GMP-ECM 5.0-beta [powered by GMP 4.1.2]
Input number is 13155161912808540373988986448257115022677318870175067553764004308210487 (71 digits)
Pollard P-1 Method with B1=5000000, B2=272993793, x^2
Using seed=3786455126
Stage 1 took 5590ms
Stage 2 took 5300ms

The file "toto" now contains some information about the method use, the stage
1 bound, the number to factor, the value X at the end of stage 1 (in hexa-
decimal), and a checksum to verify that no data was corrupted:

$ cat toto
METHOD=P-1; B1=5000000; N=13155161912808540373988986448257115022677318870175067553764004308210487; X=0x10758be718f6f2b073560c3b25719a1cc070541ea77c33a9e5639f987de; CHECKSUM=2852819094; PROGRAM=GMP-ECM 5.0-beta; X0=0xe1b0b856; TIME=Thu Feb 13 19:00:40 2003;

Then one can resume the computation with larger B1 and/or B2 as follows:

$ ./ecm -resume toto 1e7
GMP-ECM 5.0-beta [powered by GMP 4.1.2]
Resuming P-1 residue saved with GMP-ECM 5.0-beta on Thu Feb 13 19:00:40 2003 
Input number is 13155161912808540373988986448257115022677318870175067553764004308210487 (71 digits)
Pollard P-1 Method with B1=5000000-10000000, B2=732940912, x^2
Using seed=7099811799078274438499407444687937142532482907012972881923709769189342
Using mpz_powm
Stage 1 took 5510ms
Stage 2 took 10150ms
********** Factor found in step 2: 1448595612076564044790098185437
Found probable prime factor of 31 digits: 1448595612076564044790098185437
Probable prime cofactor 9081321110693270343633073697474256143651 has 40 digits

The second run only considered the primes in [5000000-10000000] in stage 1,
which saved half the time of stage 1.

The format used is the following:
  - each line corresponds to a composite
  - a line contains assignments <id>=<value> separated by semi-colons ';'
  - possible values for <id> are 
    - METHOD (value = ECM or P-1 or P+1)
    - SIGMA (value = ECM sigma parameter) [optional]
    - B1 (first stage bound)
    - N (composite to factor)
    - X (value at the end of stage 1)
    - A (A-parameter of the elliptic curve)
    - X0 (initial point for ECM, or initial residue for P-1/P+1) [optional]
    - PROGRAM (program used to perform stage 1, useful for factor credits)
  SIGMA and X0 would be optional, and would be mainly be used in case of a
  factor is found, to be able to reproduce the factorization. 

##############################################################################

How to get the best of gmp-ecm?

Choice of modular multiplication. The ecm program may choose between 4 kinds
of modular arithmetic:

(1) Montgomery's REDC algorithm at the word level (option -modmuln).
    It is quite fast for small numbers, but has quadratic asymptotic
    complexity.
(2) classical GMP arithmetic (option -mpzmod).
    Has some overhead with respect to (1) for small sizes, but wins
    over (1) for larger sizes since it has quasi-linear asymptotic
    complexity.
(3) Montgomery's REDC algorithm at high level (option -redc).
    This essentially replaces each division by two multiplications.
    Slower than (1) and (2) for small inputs, but better for large
    or very large inputs.
(4) base-2 arithmetic for numbers dividing 2^n+1 or 2^n-1.
    Each division has only linear time, but the multiplication are
    most expensive since they are done on larger numbers.

The ecm program automatically selects what he thinks is the best
arithmetic for the given input number. You may choose the best
arithmetic for a given number by trying options -modmulm, -mpzmod, -redc.
(The best choice should not depend on B1 and B2.)

Number of stage 2 blocks. The stage 2 range [B1,B2] is divided into k 
"big blocks". The default value of k is chosen to be near to optimal.
However, it may be that for a given (B1,B2) pair, another value of k
may be better. Try for this to give the option -k <value> to ecm,
where <value> is 1, 2, 3, ... Below we give the experimental best
value for a 155-digit number, for some values of B1 and the
corresponding default value of B2.

      B1      optimal k
     1e6         4
     3e6         5
    11e6         5

Optimal gmp thresholds. The default configuration of gmp-ecm requires
only the default gmp installation, in particular it only needs the
gmp.h header file from GMP. This default configuration uses some
default thresholds (in particular for subquadratic multiplication 
and division) that may not be optimal on a given machine. To get
the optimal thresholds on your machine, you need the headers
files from the GMP build directory, and to add -DWANT_GMP_IMPL to
the C flags in Makefile.



