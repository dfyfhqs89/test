This is the README file for gmp-ecm,

Table of contents of this file:
1. Files included in this distribution.
2. Main changes with respect to gmp-ecm 4c.
3. How to efficiently use P-1, P+1 and ECM?
4. Extra factors and Brent-Suyama's extension.
5. Memory usage.
6. Expression syntax reference for gmp-ecm's syntax parser.
7. Options -save and -resume.
8. working with very large numbers (the -prp* options)
9. How to get the best of gmp-ecm?
10. Command line options.
11. Known problems.
12. Record factors.

##############################################################################

1. Files included in this distribution.

COPYING - GNU GENERAL PUBLIC LICENSE
ChangeLog - Changes with respect to previous version
INSTALL - instructions to install gmp-ecm
Makefile - to build the binary file 'ecm'
README - this file
auxi.c - auxiliary functions
b1_ainc.c - code to "compute" the amount of B1 to increment (based upon
            table of expected curves, per size)
bestd.c - routines to determine the best step 2 parameters
c155 - test file containing a 155-digit composite
candi.c - structure (and code) to handle the work in process candidates.
ecm.c - factorization routine using the Elliptic Curve Method
ecm.h - header file for gmp-ecm
ecm2.c - ECM step 2 routines
eval.c - expression evalutation and file input reading routines.
getprime.c - dynamic Eratosthenes sieve
listz.c - arithmetic on lists of integers mod n
lucas.c - functions to evaluate Lucas sequences
main.c - main file for gmp-ecm, P-1 and P+1
memory.c - auxiliary routines to check memory allocation
mpmod.c - modular arithmetic
mul_lo.c - low-half short product
ntl.c - interface with NTL
pm1.c - Pollard P-1 factorization routine
polyeval.c - algorithm POLYEVAL
polyz.c - routines for polynomial arithmetic
pp1.c - P+1 factorization routines
resume.c - routines to resume a computation
stage2.c - common step 2 implementation for ecm, P-1 and P+1
test.ecm - test file for ECM
test.pm1 - test file for P-1
test.pp1 - test file for P+1
test_sh.ecm test_sh.pm1 test_sh.pp1 - tests which use sh (not csh)
toomcook.c - Toom-Cook 3 and Toom-Cook 4 multiplication
trial.c - Trial division code
tune.c - auxiliary routines to compute optimal thresholds

##############################################################################

2. Main changes with respect to gmp-ecm 4c.

- the code is split into several files to make the code easier to maintain
    and compile.
- the program now implements also P-1 and P+1, with a common step 2
    (use option -pm1 to call P-1, -pp1 for P+1).
- the program can trial divide the candidate (before running the first
    curve) and can also perform a PRP primality test prior to running
    the first curve.
- step 1 is slightly faster, thanks to a new modular multiplication layer
- step 2 uses Toom-Cook 3 and Toom-Cook 4, instead of only Karatsuba
    in gmp-ecm 4c.
- an option -save enables one to save the state at the end of step 1,
  to continue it afterwards, or on a different computer (with -resume).
- it is now possible to specify a range B2min-B2max for step 2. This
  enables one to perform a huge step 2 (for a given step 1) using several 
  computers: the first one checks B1-B2, the second one B2-B3, ...
- ECM now can handle expressions instead of "raw" decimal numbers (see 
  section "6 Expression syntax reference for gmp-ecm's syntax parser" for 
  full explanation of the syntax of the expression parser)
- ECM can "loop" processing multiple curves in a single run.  ECM continues
  to find factors when they are found, as long as the cofactor is composite
  (there is an option to stop processing a candidate once any factor is found).
  Also, the B1 (and B2) value can be "adjusted" with each curve being run.
  This looping and incrementing mode is very powerful.

##############################################################################

3. How to efficiently use P-1, P+1 and ECM?

The P-1 method works well when the input number has a prime factor P such
that P-1 is "smooth", i.e. has all its prime factor less or equal the 
step 1 bound B1, except one which may be less or equal the second step
bound B2. For P=67872792749091946529, we have P-1 = 2^5 * 11 * 17 * 19 *
43 * 149 * 8467 * 11004397, so this factor will be found as long as B1 >= 8467
and B2 >= 11004397:

$ echo 67872792749091946529 | ./ecm -pm1 -x0 2809890345 8467 11004397
GMP-ECM 5.0 [powered by GMP 4.1.2] [P-1]
Input number is 67872792749091946529 (20 digits)
Using B1=8467, B2=11004397, polynomial Dickson(6), x0=2809890345
Step 1 took 10ms
Step 2 took 320ms
********** Factor found in step 2: 67872792749091946529
Found input number N

There is no need to run several times P-1 with the same B1 and B2, like
for ECM, since a factor found with one seed will be found by another one.

The P+1 method works well when the input number has a prime factor P such
that P+1 is "smooth". For P=4190453151940208656715582382315221647, we have
P+1 = 2^4 * 283 * 2423 * 21881 * 39839 * 1414261 * 2337233 * 132554351, so
this factor will be found as long as B1 >= 2337233 and B2 >= 132554351:

$ echo 4190453151940208656715582382315221647 | ./ecm -pp1 -x0 2284918860 2337233 132554351
GMP-ECM 5.0 [powered by GMP 4.1.2] [P+1]
Input number is 4190453151940208656715582382315221647 (37 digits)
Using B1=2337233, B2=132554351, polynomial x^1, x0=2284918860
Step 1 took 3300ms
Step 2 took 2460ms
********** Factor found in step 2:
4190453151940208656715582382315221647
Found input number N

However not all seeds will succeed: only half of the seeds 's' work for P+1
(namely those where the Jacobi symbol of s^2-4 and P is -1.) Unfortunately, 
since P is usually not known in advance, there is no way to ensure that this 
holds. However, if the seed is chosen randomly, there is a probability of 
about 1/2 that it will give a Jacobi symbol of -1 (i.e. the factor P will 
be found if P+1 is smooth enough). A rule of thumb is to run 3 times P+1 
with different random seeds.

The ECM method is a probabilistic method, and can be viewed in some sense
as a generalization of the P-1 and P+1 method, where we only require that
P+t is smooth, with t random of order P^(1/2). The optimal B1 and B2 bounds
have to be chosen according to the (usually unknown) size of P. The following
table gives a set of near-to-optimal B1 and B2 pairs, with the corresponding
expected number of curves to find a factor of given size (this table does not
take into account the "extra factors" found by Brent-Suyama's extension, see
below).

       digits D  optimal B1      B2        expected curves N(B1,B2,D)
          15        2e3         1.2e5             30
          20       11e3         1.4e6             90
          25        5e4         1.2e7            240
          30       25e4         1.1e8            500
          35        1e6         8.4e8           1100
          40        3e6         4.0e9           2900
          45       11e6        2.6e10           5500
          50       43e6        1.8e11           9000
          55       11e7        6.8e11          22000
          60       26e7        2.3e12          52000
          65       85e7        1.3e13          83000
          70       29e8        7.2e13         120000

          Table 1: optimal B1 and expected number of curves to find a
          factor of D digits.

Important note: the expected number of curves is significantly smaller
than the "classical" one we get with B2=100*B1. This is due to the
fact that this new version of gmp-ecm uses a default B2 which is much
larger than 100*B1 (for large B1), thanks to the improvements in step 2.

Another important note:  There is a new "-I f" switch that computes 
an "auto-calculated" increment of B1.  This "auto-computed" calculation
of B1 is based upon the table shown above (and an internal scaling
factor), and the "f" user scaling factor to also adjust this value. 
There is also a "-i n" switch which will increment B1 by a "fixed" value
(the n value).  This code is still "new" and some testing/tuning may still
be needed to obtain the optimal results, however, the -I f should currently
be "pretty" close to optimal.  The -i n has been in use for over a year
in the ecm4c-rx (x greater than 2) and has shown to be VERY powerful in
speeding up the finding of factors.  NOTE that -I 10 is a wonderful way
to find factors of the same number across 10 "simplilar" PC's at the
same time.  This will cause each "next" auto-computation of B1 to be 
scaled 10x larger than normal.  Thus the "correct" amount of work will
be done in 10 parallel systems automatically.

Even another important note:  There is a new "-B2scale f" switch which 
will multiply the "auto-computed" B2 value by a user defined scaling
factor.  This "can" speed up the finding of factors (and reduction 
in the expected number of curves needed).  This is a brand new 
experimental option, that has not yet been fully studied, however, it
does (might) kick out factors more quickly.

After performing the expected number of curves from Table 1, the
probability that a number of D digits was missed is exp(-1), i.e.
about 37%. After twice the expected number of curves, it is exp(-2),
i.e. about 14%, and so on.

Example: after performing 9000 curves with B1=43e6 and B2=1.8e11,
the probability to miss a 50-digit factor is about 37%.

In summary, we advise the following method:

0 - choose a target factor size of D digits
1 - choose "optimal" B1 and B2 values to find factors of D digits
2 - run once P-1 with those B1 and B2
3 - run 3 times P+1 with those B1 and B2
4 - run N(B1,B2,D) times ECM with those B1 and B2, where N(B1,B2,D) is the
    expected number of ECM curves with step 1 bound B1, step 2 bound B2,
    to find a factor of D digits (cf above table). 
    OR 
    run ECM -c (about_2/3_times_listed_in_table) -I 1 B1 to allow ECM to
    "auto" advance B1 after each curve.  B1 in this example would be the
    "starting" B1, as gmp-ecm would auto advance it's value.
5 - if no factor is found, either increase D and go to 0, or use another
    factorization method (MPQS, GNFS)

Note: if a factor is found in steps 2, 3 or 4, simply continue the current
      step with the remaining cofactor (if composite). There is no need
      to start again from 0, since the factorization effort on the cofactor
      is not lost.
Note2: Adjustments made using the "-B2scale f" will reduce the number of 
       curves "needed" to find factors of a gived D digits.  At this time,
       the authors of gmp-ecm can not tell you "exactly" how much a given
       scaling factor will adjust the "average" curves needed (more study
       is needed), however, rest assured, that it does increase the odds
       that any "random" curve with a certain B1 value will find a factor.

##############################################################################

4. Extra factors and Brent-Suyama's extension.

GMP-ECM may sometimes find some
"extra" factors, such that one factor of P-1, P+1 or P+t exceeds the step 2
bound B2, thanks to Brent-Suyama's extension. Let explain how it works for P-1,
since it's simpler. The classical step 2 (without Brent-Suyama's extension)
considers s^(j*d) mod N and s^i mod N, where N is the number to factor, and
s the initial seed. Here, d is fixed, and the integers i and j vary in two
sets so that j*d+/-i covers all primes in [B1, B2]. Now consider a polynomial
f(x), and compute s^f(j*d) and s^f(i) instead of s^(j*d) and s^i [thus the
classical step 2 corresponds to f(x)=x^1]. Then P will be found whenever
all but one of the factors of P-1 are <= B1, and one factor divides one
f(j*d) +/- f(i):

$ echo 1207946164033269799036708918081 | ./ecm -pm1 -k 4 -power 12 286493 25e6
GMP-ECM 5.0 [powered by GMP 4.1.2] [P-1]
Input number is 1207946164033269799036708918081 (31 digits)
Using B1=286493, B2=25000000, polynomial x^12, x0=349569250
Step 1 took 260ms
Step 2 took 750ms
********** Factor found in step 2: 1207946164033269799036708918081
Found input number N

Here the largest factor of P-1 is 83957197, which is 3.35 times larger than B2.
Warning: these "extra" factorizations may not be reproducible in future
versions of gmp-ecm, since they depend on some internal parameters that
may change.

The default polynomial used for a given B2 should be near optimal, 
i.e. give only a marginal overhead in step 2, while enabling extra factors.

##############################################################################

5. Memory usage.

Step 1 does not require much memory (about the same size as
the input number). Step 2 may be quite memory expensive, especially for
large B2, since its efficient algorithms use some large tables. To reduce
the memory usage of step 2, you may increase the 'k' parameter, which controls
the number of "blocks" performed in step 2. Multiplying the default value of
k (which is 5) by 4 will decrease the memory usage by 2. For example with 
B2=1e10 and a 155-digit number, step 2 requires about 28MB with the default
k, but only 14MB with k=32. Increasing k does, however, also increase the
time required for step 2 (see section "8. How to get the best of gmp-ecm?")

NOTE that in -b "breadth-first" mode, gmp-ecm DOES pre-read all candidate 
numbers in the input stream, so if there are lots of large numbers to be 
tested, the memory requirement WILL go up.

##############################################################################

6. Expression syntax reference for gmp-ecm's syntax parser.

With release 5.1 of GMP-ECM, it now can handle expression form of input numbers.
Here is the syntax that is handled:

1.  Raw decimal numbers (as it has always done)
2.  Comments can be placed in the file.  The C++ "one line comment"  // 
    is used.  Everythin after the // on a line (including the //) is ignored.
3.  Line continuation.  If a line ends (the very last character) with a backslash
    \ character, then it is "joined" with the next line (and of course the 
    \ is removed).
4.  All white space (space, tab, end of line) is ignored.  However, the "end of
    line" is used to "end" the expression (unless of course there is a \ 
    character before the end of line).  For example, processing this:
    1 2 3 4 5 6 7 8 9
    would be the same as processing
    123456789
5.  "common" arithmetic expressions ( * / + - % )  period . can also be used in
    place of * for multiply, and - can be unary minus (i.e.  -55555551)
6.  Grouping  ( [ { for start of group (which symbol is used does not matter)
    and ) ] } to end a group (again all 3 symbols mean the SAME thing).
7.  Exponentiation with the ^ character  (i.e.  2^24 is the same as 16777216)
8.  Simple factorial using the exclamation point !  character.  Example is
    53! == 1*2*3*4...*52*53
9.  Multi-factorial as in: n!m with an example:  15!3 == 15.12.9.6.3
10. Simple Primorial using the # character  with example of 11# == 2*3*5*7*11
11. Reduced Primorial   n#m  with example of 17#5 == 5.7.11.13.17
12. Functions are possible with the expression parser. Currently, the only 
    function added to the syntax is Phi(x,n), however other functions should 
    be easy to add in the future.

Note Expressions are "maintained" as much as possible (even if the expression
becomes longer than the decimal expansion).  Expressions are output as cofactors
(if the input was an expression).  Expressions are stored into save/resume files
(again if and ONLY if the original input was an expression, and not a expanded
decimal number).  When a factor is found, the cofactor expression is this:
(orig_expr)/factor_found   This is shown in:

GMP-ECM 5.1-beta [powered by GMP 4.1] [ECM]
Input number is 3*2^210+1 (64 digits)
Using B1=2500, B2=164648, polynomial x^1, sigma=4007218240
Step 1 took 53ms
Step 2 took 76ms
********** Factor found in step 2: 1358437
Found probable prime factor of  7 digits: 1358437
Probable prime cofactor (3*2^210+1)/1358437 has 58 digits

##############################################################################

7. Options -save and -resume.

These options are useful to save the current state of the computation after
step 1, or to exchange data with other software. It allows to perform
step 1 with gmp-ecm, and step 2 with another software (or vice-versa).

Here is an example how to reuse some P-1 computation:

$ cat c71
13155161912808540373988986448257115022677318870175067553764004308210487
$ ./ecm -save toto -pm1 -mpzmod -x0 2 5000000 < c71
GMP-ECM 5.0 [powered by GMP 4.1.2] [P-1]
Input number is 13155161912808540373988986448257115022677318870175067553764004308210487 (71 digits)
Using B1=5000000, B2=272993793, polynomial x^24, x0=2
Step 1 took 5590ms
Step 2 took 5570ms

The file "toto" now contains some information about the method use, the step
1 bound, the number to factor, the value X at the end of step 1 (in hexa-
decimal), and a checksum to verify that no data was corrupted:

$ cat toto
METHOD=P-1; B1=5000000; N=13155161912808540373988986448257115022677318870175067553764004308210487; X=0x12530157ae22ae14d54d6a5bc404ae9458e54032c1bb2ab269837d1519f; CHECKSUM=2287710189; PROGRAM=GMP-ECM 5.0; X0=0x2; WHO=zimmerma@norroy.loria.fr; TIME=Sun Feb 23 21:39:01 2003;

Then one can resume the computation with larger B1 and/or B2 as follows:

$ ./ecm -resume toto 1e7
GMP-ECM 5.0 [powered by GMP 4.1.2] [ECM]
Resuming P-1 residue saved by zimmerma@norroy.loria.fr with GMP-ECM 5.0 on Sun Feb 23 21:43:00 2003 
Input number is 13155161912808540373988986448257115022677318870175067553764004308210487 (71 digits)
Using B1=5000000-10000000, B2=732940912, polynomial x^24
Step 1 took 5600ms
Step 2 took 10500ms
********** Factor found in step 2: 1448595612076564044790098185437
Found probable prime factor of 31 digits: 1448595612076564044790098185437
Probable prime cofactor 9081321110693270343633073697474256143651 has 40 digits

The second run only considered the primes in [5e6-10e6] in step 1,
which saved half the time of step 1.

The format used is the following:
  - each line corresponds to a composite (expression ARE saved in the save file)
  - a line contains assignments <id>=<value> separated by semi-colons ';'
  - possible values for <id> are 
    - METHOD (value = ECM or P-1 or P+1)
    - SIGMA (value = ECM sigma parameter) [optional]
    - B1 (first step bound)
    - N (composite to factor)
    - X (value at the end of step 1)
    - A (A-parameter of the elliptic curve)
    - CHECKSUM (internal value to check correctness of the format)
    - PROGRAM (program used to perform step 1, useful for factor credits) 
    - X0 (initial point for ECM, or initial residue for P-1/P+1) [optional]
    - WHO (who performed step 1) 
    - TIME (date and time of first step)
  SIGMA and X0 would be optional, and would be mainly be used in case of a
  factor is found, to be able to reproduce the factorization.
  For ECM, one of the SIGMA or A values must be present, so that the
  computation can be continued on the correct curve.

Note: it is allowed to have both -save f1 and -resume f2 for the same run,
however the files f1 and f2 should be different.

Remark: you should not perform in parallel several -resume runs on the same
input with the same B1/B2 values, since those runs will do the same 
computations. Options -save/-resume is useful in the following cases:

(a) somebody did a previous step 1 computation with another software
    which is faster than gmp-ecm, and wants to perform Step 2 with
    gmp-ecm which is faster for that task.
(b) somebody did a previous step 1 for P-1 or P+1 up to a given bound
    B1, and you want to extend that computation with B1' > B1, without
    restarting from scratch. Note: this does not apply to ECM, where 
    the smoothness property depends on the (random) curve chosen, not
    on the input number.
(c) you did a huge step 1 P-1 or P+1 computation on a given machine, and you
    want to perform a huge step 2 in parallel on several
    machines. For example machine 1 tests the range B2_1-B2_2, machine
    2 tests B2_2-B2_3, ... This also decreases the memory usage for
    each machine, which is function of the range width B2min-B2max.
    For the same reason as (b), this does not apply to ECM. 

##############################################################################

8. Working with very large numbers (the -prp* options)

When working with VERY large numbers, PRP testing can become very slow when
using GMP.  A much faster program is available.  That program is OpenPFGW (pfgw).
pfgw only does a simple Fermat test, but is much faster, due to it's highly 
optimal FFT multiplcation code.  The difference at 15k digits is about 10
minutes for GMP, and about 20s for PFGW (and the difference only gets more
severe).  A limitation of OpenPFGW, is it will ONLY be a viable solution for
Intel 32 bit CPU's, as the FFT code is only built for those systems.

Chapter 10 lists more information about the -prp* options, and using them.

##############################################################################

9. How to get the best of gmp-ecm?

Choice of modular multiplication. The ecm program may choose between 4 kinds
of modular arithmetic:

(1) Montgomery's REDC algorithm at the word level (option -modmuln).
    It is quite fast for small numbers, but has quadratic asymptotic
    complexity.
(2) classical GMP arithmetic (option -mpzmod).
    Has some overhead with respect to (1) for small sizes, but wins
    over (1) for larger sizes since it has quasi-linear asymptotic
    complexity.
(3) Montgomery's REDC algorithm at high level (option -redc).
    This essentially replaces each division by two multiplications.
    Slower than (1) and (2) for small inputs, but better for large
    or very large inputs.
(4) base-2 arithmetic for numbers dividing 2^n+1 or 2^n-1.
    Each division has only linear time, but the multiplication are
    most expensive since they are done on larger numbers.

What a "small" or "large" number means depend on the configuration.
The "tune" program helps to determine the thresholds between different
methods. Simply type "make tune", then "./tune".

The ecm program automatically selects what he thinks is the best
arithmetic for the given input number. If that choice is not optimal, you may 
force the use of a certain arithmetic by trying options -modmulm, -mpzmod, 
-redc. (The best choice should depend on B1 and B2 only very little, so long 
as B1 is not too small, say >= 1000.)

The "tune" program helps you to determine the optimal threshold for
your computer. After compiling it with "make tune", type "./tune"
and it will display timings for each method (mpzmod, modmuln, redc)
for numbers of limbs equal to 1, 2, 3, ... When the best thresholds
can be determined, the program stops and displays their values. Then
simply (re)compile ecm, adding -DMPZMOD_THRESHOLD=xxx -DREDC_THRESHOLD=yyy
in CFLAGS.

Number of step 2 blocks. The step 2 range [B1,B2] is divided into k 
"big blocks". The default value of k is chosen to be near to optimal.
However, it may be that for a given (B1,B2) pair, another value of k
may be better. Try for this to give the option -k <value> to ecm,
where <value> is 1, 2, 3, ... This will force ecm to divide step 2
in at least <value> blocks.

Changing the value of the number of blocks will not modify the chance
of finding a factor (except for extra factors, but some will be lost,
and some will be won, so the balance should be even). However it will
increase the time spent in Step 2 (when less or greater than the
optimal value), and modify the memory used by Step 2 (see the section 
"5 Memory usage").

Optimal gmp thresholds. The default configuration of gmp-ecm requires
only the default gmp installation, in particular it only needs the
gmp.h header file from GMP. This default configuration uses some
default thresholds (in particular for subquadratic multiplication 
and division) that may not be optimal on a given machine. To get
the optimal thresholds on your machine, you need the headers
files from the GMP build directory, and to add -DWANT_GMP_IMPL to
the C flags in Makefile.

##############################################################################

10. Command line parameters and options.

The usage of the "ecm" command is the following:

$ ecm [options] [-inp file ] B1 [[B2min-]B2] [ < file ] 

Parameters:
- B1 is the step 1 bound. It is the ONLY mandatory parameter. It can
  be given either in integer format (for example 3000000) or in
  floating-point format (3000000.0 or 3e6). The largest possible
  B1 value is 9007199254740996 for P-1, 4294967295 for ECM and P+1.
  All primes 2 <= p <= B1 are processed in step 1.
- B2 is the step 2 bound. It is optional: if not given, it is computed
  from B1 so that step 2 takes about half the time of step 1. Since the
  relative cost of both steps differs with the different methods, the
  default B2 value also differs; for the same B1, the default B2 for
  P+1 will be larger than that for P-1, and that for ECM will be still
  larger. Like B1, it can be given either in integer or in floating-point 
  format. The largest possible value of B2 depends on the number of blocks
  in step 2 (see option -k); it is about 10^13*k.
  All primes B1 <= p <= B2 are processed in step 2. If B2 < B1, no step 2
  is performed.
- alternatively one may use the B2min-B2max form, which means that all
  primes B2min <= p <= B2max should be processed. Thus specifying only B2 
  corresponds to B1-B2.
-inp file   Use file as input (instead of redirecting stdin).  This mode
  also "defaults" to the -b bredthfirst mode (use -d to change this to depth
  first search).  If both the -inp file and stdin is redirected (using < file),
  then the stdin is IGNORED.  The inp file take precedence.
  NOTE inp file MUST come before B1 (so it is more like an "option"), and can
  actually occur anywhere before B1 (if there are more options entered), 
  however it's "overriding of the [ < file] places it into the Parameters
  section.

Options: options must appear before the parameters, and can be in any order.

Options to control the factorization method [ECM is the default]:
-pm1  Perform P-1 instead of ECM.
-pp1  Perform P+1 instead of ECM.
-t n  Trial divide candidates before P-1, P+1 or ECM up to n.  If ECM is in
   looping mode, then -t n will ONLY affect finding factors before running
   the first curve.

Options to control the group and initial point used:
-x0 x  [P-1,P+1,ECM]. Use x as initial point. x can be an arbitrary-precision
   integer or rational. For example, -x0 1/3 is valid. If not given, x0 is
   either generated from the sigma value for ECM, or at random.
-sigma s  [ECM]. Use s (arbitrary-precision integer) as curve generator.
   If not given, sigma is generated at random (32-bit integer). Any
   value has the same probability to hit a factor, the only important 
   thing is to ensure different values for different runs on the same number.
-A a  [ECM]. Use 'a' (arbitrary-precision integer) as curve parameter.
   If not given, is generated from sigma. Like sigma, the value of A itself
   is not important; what is important is to ensure different values
   for different runs.
-go <VAL>   [P-1,P+1,ECM].  Preload with Group Order value of VAL.  VAL can
   be a simple number (such as 12345) or any valid expression (such as 2^40)
   or it can be an expression that contains the special character N, (such
   as N^2-1).  If the expression contains the N character, then the expression
   is recomputed before for each curve, and the value of the candidate is 
   substituted into the expression.  For instance:
   echo 111112222334567 | ecm -go N^2-1 -pm1 5000   will convert the -go
   expression into 111112222334567^2-1 then evaluated, before processing
   the P-1.  

Options to control step 2 parameters:
-k n  [P-1,P+1,ECM]. Perform >= n blocks in step 2 (default is 0). See
   section "5. Memory usage" above.
-power n  Use x^n for Brent-Suyama's extension (see section "4. Extra 
   factors and Brent-Suyama's extension"). Default is chosen depending on
   method and B2. For P-1, n should be even. Does not work with P+1.
-dickson n  Use degree-n Dickson's polynomial for Brent-Suyama's
   extension, instead of x^n. As for x^n, 'n' should be even for P-1. 
   Dickson polynomials give a better chance of finding factors, but for
   P-1 and n>6, x^n is faster. Does not work with P+1.
-B2scale f   Multiplies the 'computed' B2 value by the specified 
   multiplier.  The multipler must be above 0.02, and in many cases,
   it must be "below" a certain threashold (See info about B2 and -k).

Options to control output:
-q  Quiet mode. Found factors are printed on standard error, and
    cofactors (if not probable prime) are printed on standard output.
    This option is useful to deal with a file of cofactors: type
    ecm B1 < file > file2, so that non-factored numbers and composite
    cofactors are written in file2, while factors found are printed on
    standard error. Then one can do ecm B1 < file2 > file3, ...
-v  Verbose mode. Several informations are printed (modular
    multiplication used, initial A and x0 values, value of x at the end
    of step 1, parameters for step 2, and timing for sub-steps from step 2).
-cofdec   Force cofactor output in decimal (even if expressions are used)
-ve n     Verbosely show short (< n character) expressions on each loop.
          This gives a "better" feel for what is being processed when
          expressions are used.
-ticdelay n This will cause the percentage ticks to only output every n
            ms.  If n is -1, then the tic display will NOT happen at all.

Options to control modular arithmetic (see "How to get the best of gmp-ecm?"):
-mpzmod   Use GMP's mpz_mod for modular reduction.
-modmuln  Use Montgomery's MODMULN for modular reduction.
-redc     Use Montgomery's REDC for modular reduction.
-nobase2  Disable special base-2 code. Base-2 division is used
          when the input number if a factor of 2^n+1 or 2^n-1,
          and the ratio of the number of bits is not too small.

Options for saving and resuming to/from files (see section "7. Options
   -save and -resume"):
-save file    Save residues at end of step 1 to file.
-resume file  Resume residues from file, reads from stdin if file is "-".
              NOTE that incremental saving of the save file during B1 
              mode "IS" a work in progress.  It has been added, but is
              not yet working.  Thus it has currently been "commented"
              out in the source code, until one of the other ECM
              developers (with more in-depth knowledge of the code), 
              gets it working.

Options for prp testing using extern proces 
  (i.e. prp testing using OpenPFGW)  see section "8. Working with very large
  numbers (the -prp* options)
-prp cmd     use shell command cmd to do large primality tests.  Withing the
             cmd part, there are these escape sequences:  %n will be replaced
             with the decimal number needing checked for prp,  %l will be 
             replaced by the "file" part of -prplog, and %t will be replaced
             with the "file" part of -prptmp.  Also any character possible
			 can be output using the escape %x[0-9a-f][0-9a-f], thus special
			 chars that some broken shells do not like to allow, can be used.
             All other characters within the cmd will be replaced verbetim,
             and the system call will be made to exectute the cmd.  NOTE in
             PFGW, only a Fermat test is dome (with a default of Fermat-3).
             If testing numbers of the form 3^??? +-1 (or factors thereof),
             or any other number form where Fermat-3 failes, be SURE to add
             a -bn (replace n with a number from 2 to 255), and a Fermat-n
             test will be performed.  
             Example"  -prp "pfgw -q%n >/dev/nul 2>/dev/nul -b139"
-prplen n    The external prp tester (PFGW) will be called only when 
             candidate numbers are longer (decimal length) than this number 
             of digits.  The "default" is 800 decimal digits.
-prpval n    Return code which indicates the prp command found the number 
             to be PRP.  The "latest" version of PFGW returns a 0 for 
             Prp or Prime.  IF this switch is NOT set, then ecm will 
             use the prplog and prpyes/prpno values.  Only the latest
             versions of PFGW correctly return errorcode listing PRP or 
             composite.
-prplog file If not using prpval, then get PRP results from this file.
             This file will be deleted after the test is run (and the 
             results are pulled from it.
-prptmp file This will cause the n value to be written to this temp file
             prior to the command being run.  If working with REALLY big
             numbers (i.e. numbers larger than what the command line can
             support), then this will write them to a file, and the program
             doing the PRP testing must be able to read the number from 
             a file.  The number will be written as one very long string,
             with only a single end of line marker at the very end of the
             number.
-prpyes str  literal string found in prplog file when number is PRP.  The
             default string to scan for is "-PRP!"
-prpno str   literal string found in prplog file when number is composite.
             The default string to scan for is "is composite"


Miscellaneous options:
-primetest  Perform a primality test on input number, and prints a
      message if it is probably prime. This is not done by default since
      the primality test may be quite expensive (especially for large
      input).
-c n  Perform n runs on each input number instead of just one by
      default. The runs are stopped before n in case a factor is found.
      This option is mainly useful for P+1 (for example with c=3) or for
      ECM, where n is the expected number of curves corresponding to a
      given B1 in Table 1 (see "How to efficiently use P-1, P+1 and
      ECM?"). This option is incompatible with -resume, -sigma, -x0.
      Giving -c 0 will emulate an infinite loop until a factor is found.
-i n  increment B1 by this constant on each run
-I f  auto-calculated increment for B1 multiplied by 'f' scale factor
-b    Use breadth-first mode of file processing (recommended). In this
      mode, all (remaining) candidates are tested, before being tested
      with a 2nd (3rd, 4th, ...) curve.  In this mode, the file is "pre-
      read" and all expressions are processed to reside in-memory.  This
      is NOT a good thing if the data is not limited (i.e. coming from a
      pipe of unknown size, or from a "server").  If that is the case 
      (i.e. the size of the input is unbounded), then DO NOT use the -b
      mode.  The -b mode is not needed to be specified if the -inp filename
      is used (it is the default for that mode). The -b "can" be used
      for redirection (i.e.  ecm -c 50 -b 50000 < in-data) will process
      this data in breadth-first mode.
-d    Use depth-first mode of file processing.  In this mode (the
      default mode for input redirection), each candidate is tested the
      required number of curves, before testing the next candidate.
-n    run ecm in "nice" mode (below normal priority)
-nn   run ecm in "very nice" mode (idle priority)
-one  Stop processing a candidate if a factor is found (looping mode).
      By default, ECM will continue processing the cofactor (as long as
      it is still composite) in looping mode.



##############################################################################
        
11. Known problems.

(a) Under some operating systems (in particular Windows), ecm may use the
same random seed for several curves started during the same second. 
  *** this has been fixed in version 5.1 compiled with MinGW32 ***
This is due to the fact that the getpid() function returns a constant
value under those systems. This will cause an efficiency loss, since
the same computation will be done twice. A workaround is to wait at
least one second between different curves on the same number, or to
specify by hand a different seed using the -sigma or -x0 options.
In all cases, when running several curves on the same number, it is
safe to check that the sigma/x0 values are different for each run.

(b) Under some operating systems (for example FreeBSD), you may have
to comment the #include <alloca.h> line in ecm-gmp.h. If that still
does not work, then you need the GMP build file gmp-impl.h, and add
-DWANT_GMP_IMPL to CFLAGS.

(c) stderr output was mixed with stdout output.  This allows redirection
of output to a file, with ecm-gmp giving a VERY useful single line, listing
many good statistics of what is happening (current line of the file, current
"curve" count and total curve count to do, number of factors found, current
B1 level, ...)  The output also looks fine if stdout is not redirected
(stdout overwrites the stderr information and "looks right").  However, 
there can be some "strangeness" in some screen output if the stdout is being
handled by an external process (i.e. something like tee).  Since ecm-gmp 
is sending data to the screen which was sent to stderr, yet ecm-gmp does
not write to the screen on it's stdout output (tee is getting that output
and IT is writing it to screen), then some of the written output (to 
screen only), can get slightly "messed up" (out of order screen drawing.
There currently is no work around for this if using something like tee,
however, if you "do" want to "watch" the output to screen (while storing
it to file like you should be doing), then simply use absolute redirection
to a file, then use tail -f to "view" the outputted data.  The benefit
of this is that you get a VERY nice 1 line screen output, yet on a different
screen, can "see" the work as it is done, while still having the data
stored to disk (in case of power outage, or other catastophe).

(d) there may be "strangeness" caused by the writing to stderr. I can not 
fully comment on this due to my lack of usage of the  ecm client server (or
using ecm as:   "ecm options < in & nohup" (or whatever the syntax is for
running unnending in the background in *nix (Paul, please test how the
current version works under these conditions, then either update this 
known problem, or remove it if it is not a problem).
        
##############################################################################

12. Record factors.

If you find a very large factor, the program will print a message like:

Report your potential champion to <email address>
(see <url for record factors>)

This means that your factor might be a champion, i.e. one of the top-ten
largest factors ever found by the corresponding method (P-1, P+1 or ECM).
Cf the following URLs:

ECM: ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Richard.Brent/champs.txt
P-1: http://www.loria.fr/~zimmerma/records/Pminus1.html
P+1: http://www.loria.fr/~zimmerma/records/Pplus1.html
