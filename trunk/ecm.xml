<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<!-- lifted from troff+man by doclifter -->
<refentry>
<!--                                       Hey, EMACS: \-*\- nroff \-*\- -->
<!--  First parameter, NAME, should be all caps -->
<!--  Second parameter, SECTION, should be 1\-8, maybe w/ subsection -->
<!--  other parameters are allowed: see man(7), man(1) -->
<refmeta>
<refentrytitle>ECM</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='source'>April 22, 2003</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>ecm</refname>
<refpurpose>factor integers using the Elliptic Curve Method</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv id='synopsis'>
<cmdsynopsis>
  <command>ecm</command>    
    <arg choice='opt'><replaceable>options</replaceable></arg>
    <arg choice='plain'><replaceable>B1</replaceable></arg>
    <group choice='opt'><arg choice='plain'><replaceable>B2min-B2man</replaceable></arg><arg choice='plain'><replaceable>B2</replaceable></arg></group>
    <sbr/>
</cmdsynopsis>
</refsynopsisdiv>


<refsect1 id='description'><title>DESCRIPTION</title>
<para>This manual page documents briefly the
<command>ecm</command>
command.
This manual page was written for the Debian distribution
because the original program does not have a manual page. Please have
a look at /usr/share/doc/gmp-ecm/README.gz for a more detailed
documentation.</para>

<para>ecm is an integer factoring program using the elliptic curve
method. The following sections describe parameters relevant to this
algorithm.</para>

</refsect1>

<refsect1 id='step_1_parameters'><title>STEP 1 PARAMETERS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'>B1</emphasis></term>
  <listitem>
<para>B1 is the step 1 bound. It is a mandatory parameter. It can be given
either in integer format (for example 3000000) or in floating-point
format (3000000.0 or 3e6). The largest possible B1 value is
9007199254740996 for P-1, 4294967295 for ECM and P+1.  All primes 2 &lt;=
p &lt;= B1 are processed in step 1.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>B2</emphasis></term>
  <listitem>
<para>B2 is the step 2 bound. It is optional: if not given, it is computed
from B1 so that step 2 takes about half the time of step 1. Since the
relative cost of both steps differs with the different methods, the
default B2 value also differs; for the same B1, the default B2 for P+1
will be larger than that for P-1, and that for ECM will be still
larger. Like B1, it can be given either in integer or in
floating-point format. The largest possible value of B2 depends on the
number of blocks in step 2 (see option -k); it is about
9846466279650*k.  All primes B1 &lt;= p &lt;= B2 are processed in step 2. If
B2 &lt; B1, no step 2 is performed.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'>Bmin-Bman</emphasis></term>
  <listitem>
<para>alternatively one may use the B2min-B2max form, which means that all
primes B2min &lt;= p &lt;= B2max should be processed. Thus specifying only
B2 corresponds to B1-B2.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='factoring_method'><title>FACTORING METHOD</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option>-pm1</option></term>
  <listitem>
<para>Perform P-1 instead of ECM.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-pp1</option></term>
  <listitem>
<para>Perform P+1 instead of ECM.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='group_and_initial_point_parameters'><title>GROUP AND INITIAL POINT PARAMETERS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option>-x0 x</option></term>
  <listitem>
<para>[ECM, PM1, PP1] Use x as initial point. x can be an
arbitrary-precision integer or rational. For example, -x0 1/3 is
valid. If not given, x0 is either generated from the sigma value for
ECM, or at random.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-sigma s</option></term>
  <listitem>
<para>[ECM]. Use s (arbitrary-precision integer) as curve generator. If not
given, sigma is generated at random (32-bit integer). Any value has
the same probability to hit a factor, the only important thing is to
ensure different values for different runs on the same number.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-A a</option></term>
  <listitem>
<para>[ECM]. Use 'a' (arbitrary-precision integer) as curve parameter. If
not given, is generated from sigma. Like sigma, the value of 'a'
itself is not important; what is important is to ensure different
values for different runs.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='step_2_parameters'><title>STEP 2 PARAMETERS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option>-k n</option></term>
  <listitem>
<para>[P-1,P+1,ECM]. Perform n blocks in step 2 (default is 5). Setting a
higher value require less memory in step 2, but needs more time.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-power n</option></term>
  <listitem>
<para>Use x^n for Brent-Suyama's extension (see paragraph "4. Extra factors
and Brent-Suyama's extension"). Default is chosen depending on method
and B2. For P-1, n should be even. Does not work with P+1.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-dickson n</option></term>
  <listitem>
<para>Use degree-n Dickson's polynomial for Brent-Suyama's extension,
instead of x^n. As for x^n, 'n' should be even for P-1. Dickson
polynomials give a better chance of finding factors, but for P-1 and
n&gt;6, x^n is faster. Does not work with P+1.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='output'><title>OUTPUT</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option>-q</option></term>
  <listitem>
<para>Quiet mode. Found factors are printed on standard error, and cofactors
(if not probable prime) are printed on standard output. This option is
useful to deal with a file of cofactors: type ecm B1 &lt; file &gt; file2,
so that non-factored numbers and composite cofactors are written in
file2, while factors found are printed on standard error. Then one can
do ecm B1 &lt; file2 &gt; file3, ...</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-v</option></term>
  <listitem>
<para>Verbose mode. Several informations are printed (modular multiplication
used, initial A and x0 values, value of x at the end of step 1,
parameters for step 2, and timing for sub-steps from step 2).</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='modular_arithmetic_options'><title>MODULAR ARITHMETIC OPTIONS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option>-mpzmod</option></term>
  <listitem>
<para>Use GMP's mpz_mod for modular reduction.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-modmuln</option></term>
  <listitem>
<para>Use Montgomery's MODMULN for modular reduction.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-redc</option></term>
  <listitem>
<para>Use Montgomery's REDC for modular reduction.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-nobase2</option></term>
  <listitem>
<para>Disable special base-2 code. Base-2 division is used when the input
number is a factor of 2^n+1 or 2^n-1, and the size of the input number
is not too small compared to the size of 2^n+/-1. The threshold is
optimized for Cunningham numbers.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='file_io'><title>FILE I/O</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option>-save file</option></term>
  <listitem>
<para>Save residues at end of step 1 to file.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-resume file</option></term>
  <listitem>
<para>Resume residues from file, reads from stdin if file is "-".</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='miscellaneous'><title>MISCELLANEOUS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option>-primetest</option></term>
  <listitem>
<para>Perform a primality test on input number, and prints a message if it
is probably prime. This is not done by default since the primality
test may be quite expensive (especially for large input).</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option>-c n</option></term>
  <listitem>
<para>Perform n runs on each input number instead of just one by
default. The runs are stopped before n in case a factor is found. This
option is mainly useful for P+1 (for example with c=3) or for ECM,
where n is the expected number of curves corresponding to a given B1
in Table 1 (see "How to efficiently use P-1, P+1 and ECM?"). This
option is incompatible with -resume, -sigma, -x0. Giving -c 0 will
emulate an infinite loop until a factor is found.</para>

  </listitem>
  </varlistentry>
</variablelist>

<!--  TeX users may be more comfortable with the \fB&lt;whatever&gt;\fP and -->
<!--  \fI&lt;whatever&gt;\fP escape sequences to invode bold face and italics,  -->
<!--  respectively. -->
</refsect1>

<refsect1 id='author'><title>AUTHOR</title>
<para>The gmp-ecm software was written by Paul Zimmermann &lt;zimmerma@loria.fr&gt;
and  Alexander Kruppa &lt;alexander.kruppa@stud.tu-muenchen.de&gt;.
This manual page was written by Laurent Fousse &lt;laurent@komite.net&gt;,
for the Debian GNU/Linux system (but may be used by others).</para>
</refsect1>
</refentry>

