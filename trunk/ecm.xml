<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                   "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<!-- lifted from troff+man by doclifter -->
<refentry>
<!--                                       Hey, EMACS: \-*\- nroff \-*\- -->
<!--  First parameter, NAME, should be all caps -->
<!--  Second parameter, SECTION, should be 1\-8, maybe w/ subsection -->
<!--  other parameters are allowed: see man(7), man(1) -->
<refmeta>
<refentrytitle>ECM</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='source'>April 22, 2003</refmiscinfo>
</refmeta>
<refnamediv id='name'>
<refname>ecm</refname>
<refpurpose>integer factorization using ECM, P-1 or P+1</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv id='synopsis'>
<cmdsynopsis>
  <command>ecm</command>    
    <arg choice='opt'><replaceable>options</replaceable></arg>
    <arg choice='plain'><replaceable>B1</replaceable></arg>
    <group choice='opt'><arg choice='plain'><replaceable>B2min-B2max</replaceable></arg><arg choice='plain'><replaceable>B2</replaceable></arg></group>
    <sbr/>
</cmdsynopsis>
</refsynopsisdiv>


<refsect1 id='description'><title>DESCRIPTION</title>
<para>ecm is an integer factoring program using the Elliptic Curve
Method (ECM), the P-1 method, or the P+1 method.
The following sections describe parameters relevant to this
algorithm.</para>

</refsect1>

<refsect1 id='step_1_parameters'><title>STEP 1 PARAMETERS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><emphasis remap='B'><replaceable>B1</replaceable></emphasis></term>
  <listitem>
<para><replaceable>B1</replaceable> is the step 1 bound. It is a mandatory parameter. It can be given
either in integer format (for example 3000000) or in floating-point
format (3000000.0 or 3e6). The largest possible <replaceable>B1</replaceable> value is
9007199254740996 for P-1, ULONG_MAX for ECM and P+1.  All primes 2 &lt;=
p &lt;= <replaceable>B1</replaceable> are processed in step 1.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'><replaceable>B2</replaceable></emphasis></term>
  <listitem>
<para><replaceable>B2</replaceable> is the step 2 bound. It is optional: if omitted, a default value is
computed from B1, which should be close to optimal.
Like B1, it can be given either in integer or in
floating-point format. The largest possible value of <replaceable>B2</replaceable> depends on the
number k of blocks in step 2 (see option -k), and is of the form b2_max*k.
All primes B1 &lt;= p &lt;= <replaceable>B2</replaceable> are processed in step 2. If
<replaceable>B2</replaceable> &lt; B1, no step 2 is performed.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><emphasis remap='B'><replaceable>B2min-B2max</replaceable></emphasis></term>
  <listitem>
<para>alternatively one may use the <replaceable>B2min-B2max</replaceable> form, which means that all
primes B2min &lt;= p &lt;= B2max should be processed. Thus specifying B2 only
corresponds to B1-B2.</para>
  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='factoring_method'><title>FACTORING METHOD</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option><replaceable>-pm1</replaceable></option></term>
  <listitem>
<para>Perform P-1 instead of the default method (ECM).</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><option><replaceable>-pp1</replaceable></option></term>
  <listitem>
<para>Perform P+1 instead of the default method (ECM).</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><option><replaceable>-t n</replaceable></option></term>
  <listitem>
<para>Perform trial division up to <replaceable>n</replaceable>,
before P-1, P+1 or ECM.  In looping mode (option
<replaceable>-c</replaceable>), trial division is only performed
in the first run.
</para>
  </listitem>
  </varlistentry>

</variablelist>
</refsect1>

<refsect1 id='group_and_initial_point_parameters'><title>GROUP AND INITIAL POINT PARAMETERS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option><replaceable>-x0 x</replaceable></option></term>
  <listitem>
<para>[ECM, P-1, P+1] Use <replaceable>x</replaceable> 
(arbitrary-precision integer or rational)
as initial point. For example, -x0 1/3 is
valid. If not given, <replaceable>x</replaceable> is generated from the sigma
value for ECM, or at random for P-1 and P+1.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-sigma s</replaceable></option></term>
  <listitem>
<para>[ECM] Use <replaceable>s</replaceable> (arbitrary-precision integer) as
curve generator. If omitted, <replaceable>s</replaceable> is generated at
random.</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><option><replaceable>-A a</replaceable></option></term>
  <listitem>
<para>[ECM] Use <replaceable>a</replaceable> (arbitrary-precision integer) as
curve parameter. If omitted, is it generated from the sigma value.
</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><option><replaceable>-go val</replaceable></option></term>
  <listitem>
<para>[ECM, P-1, P+1] Exponentiate the initial point x0 to order
<replaceable>val</replaceable>, which can any valid expression,
possible containing the special character N, as place holder for the current
input number.
</para>
  </listitem>
  </varlistentry>

</variablelist>
</refsect1>

<refsect1 id='step_2_parameters'><title>STEP 2 PARAMETERS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option><replaceable>-k n</replaceable></option></term>
  <listitem>
<para>[ECM, P-1, P+1] Perform <replaceable>n</replaceable> blocks in step 2.
Increasing <replaceable>n</replaceable> decreases the memory usage of
step 2, at the expense of some cpu time.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-power n</replaceable></option></term>
  <listitem>
<para>[ECM, P-1]
Use <replaceable>x^n</replaceable> for Brent-Suyama's extension
(<replaceable>-power 1</replaceable> disables Brent-Suyama's extension).
The default polynomial is chosen depending on the method and B2.
For P-1, <replaceable>n</replaceable> should be even.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-dickson n</replaceable></option></term>
  <listitem>
<para>[ECM, P-1]
Use degree-n Dickson's polynomial for Brent-Suyama's extension.
Like for <replaceable>-power n</replaceable>, <replaceable>n</replaceable>
should be even for P-1.</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='output'><title>OUTPUT</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option><replaceable>-q</replaceable></option></term>
  <listitem>
<para>Quiet mode. Found factorizations are printed on standard output,
with factors separated by white spaces, one line per input number
(if no factor was found, the input number is simply copied).
</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-v</replaceable></option></term>
  <listitem>
<para>Verbose mode. Several informations are printed (kind of modular
multiplication used, initial A and x0 values, value of x at the end of step 1,
parameters for step 2, timings for sub-steps from step 2,
expected curves and time to find factors of different sizes).</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='modular_arithmetic_options'><title>MODULAR ARITHMETIC OPTIONS</title>
Several algorithms are available for modular multiplication.
The program tries to find the best one for each input;
one can force a given method with the following options.
<variablelist remap='TP'>
  <varlistentry>
  <term><option><replaceable>-mpzmod</replaceable></option></term>
  <listitem>
<para>Use GMP's mpz_mod function (subquadratic for large inputs, but induces
some overhead for small ones).</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-modmuln</replaceable></option></term>
  <listitem>
<para>Use Montgomery's multiplication (quadratic version). Usually
best method for small input.</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-redc</replaceable></option></term>
  <listitem>
<para>Use Montgomery's multiplication (subquadratic version).
Theoretically optimal for large input.</para>
  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-nobase2</replaceable></option></term>
  <listitem>
<para>Disable special base-2 code (which is used when the input number is a
large factor of 2^n+1 or 2^n-1, see <replaceable>-v</replaceable>).</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='file_io'><title>FILE I/O</title>
The following options enable one to perform step 1 and step 2 separately,
either on different machines, at different times, or using different
software (in particular, George Woltman's Prime95/mprime program uses the
same convention for save files).
It can also be useful to split step 2 into several runs,
using the <replaceable>B2min-B2max</replaceable> option.
<variablelist remap='TP'>
  <varlistentry>
  <term><option><replaceable>-save file</replaceable></option></term>
  <listitem>
<para>Save result of step 1 in <replaceable>file</replaceable>.
Example: <replaceable>ecm -save foo 1e6 1 &lt; c155</replaceable> performs
only step 1, and saves its result in file <replaceable>foo</replaceable>.
</para>

  </listitem>
  </varlistentry>
  <varlistentry>
  <term><option><replaceable>-resume file</replaceable></option></term>
  <listitem>
<para>Resume residues from <replaceable>file</replaceable>, reads from stdin
if <replaceable>-resume -</replaceable>.
Example: <replaceable>ecm -resume foo 1e6</replaceable> performs step 2
corresponding to the above step 1 computation.
</para>

  </listitem>
  </varlistentry>
</variablelist>
</refsect1>

<refsect1 id='miscellaneous'><title>MISCELLANEOUS</title>
<variablelist remap='TP'>
  <varlistentry>
  <term><option><replaceable>-primetest</replaceable></option></term>
  <listitem>
<para>Perform a primality test on the input number.
This is not done by default since the primality
test may be expensive, especially for large input.</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><option><replaceable>-c n</replaceable></option></term>
  <listitem>
<para>Perform <replaceable>n</replaceable> runs on each input number
instead of just one (default).
The runs are stopped before <replaceable>n</replaceable> if a factor is found.
This option is mainly useful for P+1 (for example with c=3) or for ECM,
where <replaceable>n</replaceable> is the expected number of curves
to find a d-digit factor with a given step 1 bound.
This option is incompatible with <replaceable>-resume, -sigma, 
-x0</replaceable>. Giving <replaceable>-c 0</replaceable>
emulates an infinite loop until a factor is found.</para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><option><replaceable>-n</replaceable></option></term>
  <listitem>
  <para>Run the program in <quote>nice</quote>mode (below normal priority).
  </para>
  </listitem>
  </varlistentry>

  <varlistentry>
  <term><option><replaceable>-nn</replaceable></option></term>
  <listitem>
  <para>Run the program in <quote>very nice</quote>mode (idle priority).</para>
  </listitem>
  </varlistentry>

</variablelist>

<!--  TeX users may be more comfortable with the \fB&lt;whatever&gt;\fP and -->
<!--  \fI&lt;whatever&gt;\fP escape sequences to invode bold face and italics,  -->
<!--  respectively. -->
</refsect1>

<refsect1 id='syntax'><title>INPUT SYNTAX</title>
The input numbers can have several forms:
<para>Raw decimal numbers like 123456789.</para>
<para>Comments can be placed in the file: everything after <quote>//</quote>
is ignored, up to the end of line.</para>
<para>Line continuation. If a line ends with a backslash character
    <quote>\</quote>, it is considered to continue on the next line.</para>
<para>Common arithmetic expressions can be used. Example:
     <replaceable>3*5+2^10</replaceable>.</para>
<para>Factorial: example <replaceable>53!</replaceable>.</para>
<para>Multi-factorial: example <replaceable>15!3</replaceable>
means 15*12*9*6*3.</para>
<para>Primorial: example <replaceable>11#</replaceable> means
2*3*5*7*11.</para>
<para>Reduced primorial: example <replaceable>17#5</replaceable> means
5*7*11*13*17.</para>
<para>Functions: currently, the only available function is 
<replaceable>Phi(x,n)</replaceable>.</para>
</refsect1>

<refsect1 id='author'><title>AUTHORS</title>
<para>
Jim Fougeron &lt;jfoug@kdsi.net&gt; contributed the expression parser and
several command-line options;
Laurent Fousse &lt;laurent@komite.net&gt; contributed the middle product code,
the autoconf/automake tools, and is the maintainer of the Debian package;
Alexander Kruppa &lt;alexander.kruppa@stud.tu-muenchen.de&gt;
contributed the Toom-Cook multiplication code, the special code for Fermat
numbers, and many other nice things;
Dave Newman &lt;david.newman@jesus.ox.ac.uk&gt;
contributed the Kronecker-Schoenhage multiplication code;
Paul Zimmermann &lt;zimmerma@loria.fr&gt; is the author of the first version
of gmp-ecm.
</para>
</refsect1>
</refentry>
