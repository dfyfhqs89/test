/* Choice of best parameters for stage 2.

  Copyright 2001, 2002, 2003, 2004, 2005 Paul Zimmermann and Alexander Kruppa.

  This file is part of the ECM Library.

  The ECM Library is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation; either version 2.1 of the License, or (at your
  option) any later version.

  The ECM Library is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
  License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with the ECM Library; see the file COPYING.LIB.  If not, write to
  the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  MA 02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h> /* for UINT_MAX */
#include "gmp.h"
#include "ecm.h"
#include "ecm-impl.h"

/* returns Euler's totient phi function */
unsigned long
phi (unsigned long n)
{
  unsigned long phi = 1, p;

  for (p = 2; p * p <= n; p += 2)
    {
      if (n % p == 0)
	{
	  phi *= p - 1;
	  n /= p;
	  while (n % p == 0)
	    {
	      phi *= p;
	      n /= p;
	    }
	}

      if (p == 2)
	p--;
    }

  /* now n is prime or 1 */

  return (n == 1) ? phi : phi * (n - 1);
}

/*
  Compute (d, d2, k) such that:
  (0) k >= k0
  (1) d is a multiple of 6
  (2) k * d * (phi(d)/2) * d2 / phi(d2) >= B2 - B2min
  (3) gcd(d, d2) == 1
  (4) k is minimal, subject to previous conditions
  Return non-zero iff an error occurred (too large step 2 bound).
 */
int
bestD (double B2min, double B2, unsigned int k0, unsigned int *finald, 
       unsigned int *finald2, unsigned int *k)
{
/* the following list contains successive values of b with
   increasing values of phi(b). It was generated by the following Maple
   program:
l := [[1,1]]:
for b from 12 by 6 do
   d:=numtheory[phi](b)/2;
   while d <= l[nops(l)][2] do l:=subsop(nops(l)=NULL, l) od;
   n := nops(l);
   if b>1.1*l[n][1] then l := [op(l), [b,d]]; lprint(l) fi;
od:
*/
#define N 100
  static double l[N] = {12, 18, 30, 42, 60, 90, 120, 150, 210, 240, 270, 330, 420, 510, 630, 840, 1050, 1260, 1470, 1680, 1890, 2310, 2730, 3150, 3570, 3990, 4620, 5460, 6090, 6930, 8190, 9240, 10920, 12180, 13860, 16170, 18480, 20790, 23100, 30030, 34650, 39270, 43890, 48510, 60060, 66990, 78540, 90090, 99330, 120120, 133980, 150150, 180180, 210210, 240240, 270270, 300300, 334950, 371280, 420420, 510510, 570570, 630630, 746130, 870870, 1021020, 1141140, 1291290, 1531530, 1711710, 1891890, 2081310, 2312310, 2552550, 2852850, 3183180, 3573570, 3993990, 4594590, 5105100, 5705700, 6322470, 7147140, 7987980, 8978970, 10210200, 11741730, 13123110, 14804790, 16546530, 19399380, 21411390, 23993970, 26816790, 29609580, 33093060, 36606570, 40330290, 44414370, 49639590};

  unsigned int i;
  unsigned int d, d2, dmin = 0, d2min = 1, dF;
  double dd2, jf;
  unsigned int j, jmin = UINT_MAX;
  int found = 0; /* non-zero when some j >= k0 was found */

  for (i = 0; i < N; i++)
    {
      d = (unsigned long) l[N - 1 - i];
      dF = phi (d) / 2;
      /* Look for smallest prime < 25 that does not divide d */
      for (d2 = 5; d2 < 25; d2 += 2)
        {
          if (d2 % 3 == 0)
            continue;
          if (d % d2 > 0)
            break;
        }
      if (d2 >= 25 || d2 - 1 > dF)
        d2 = 1;
      dd2 = (double) d * (double) d2;
      
      /* How many lines will we need ? */
      jf = ceil ((B2 + dd2 - 5.0) / dd2) - floor ((B2min - dd2) / dd2);
      /* The upper bound is B2 + dd2 - 5, because the points for the roots of
	 F only cover values == 1 (mod 6).
	 For the lower bound, we want that i*d+j*d2 covers all primes >= B2min
	 for i >= i0. It suffices that there are at least d2 multiples of d
	 that are <= B2min, thus i0*d + (d2-1)*d <= B2min, or
	 i0 <= floor(B2min/d) - (d2-1). */
      
      /* How many blocks will we need ? */
      j = (unsigned int) ceil (jf / (double) dF * (double) phi (d2));
      /* warning: if B2min=B2, we may always have j=1 here */
      if (j >= k0 || found == 0)
	{
	  /* if found=0 and j>=k0: forgot previous and keep that one */
	  if ((found == 0 && j >= k0) || j < jmin
	      || (j == jmin && d < dmin))
	    {
	      dmin = d;
	      d2min = d2;
	      jmin = j;
	    }
	  found = (j >= k0);
	}
    }

  if (dmin == 0)
    {
      fprintf (ECM_STDERR, "Error, too large step 2 bound, increase -k\n");
      return 1;
    }

  *k = jmin;
  *finald = dmin;
  *finald2 = d2min;
  
  return 0;
}

/*
  Compute (d,d2,k) such that:
  (0) k == k0 if k0 > 0, 2 <= k <= 9 otherwise
  (1) d is a multiple of 6
  (2) dF = 2^ceil(log_2(phi(d)/2)), a power of 2
  (3) k * d * d2 / phi(d2) * dF + floor(B2min / d / d2) * d * d2 >= B2 - B2min
  (4) d*d2/phi(d2) maximal
  Return non-zero iff an error occured (too large step 2 bound).
*/
int
bestD_po2 (double B2min, double B2, unsigned int *finald, 
           unsigned int *finald2, unsigned int *k)
{
/* List of d values where phi(d)/2 is just below or equal a power of 2 */
#define Npo2 23
  static unsigned int l[Npo2] = {12, 30, 60, 120, 240, 510, 1020, 2310, 4620, 
                                 9240, 19110, 39270, 79170, 158340, 324870, 
                                 690690, 1345890, 2852850, 5705700, 11741730, 
                                 23130030, 48498450, 96996900};
  /* l2[i] is always the smallest prime (or 1) not present in l[i] and < dF */
  static unsigned int l2[Npo2] = {1, 1, 7, 7, 7, 7, 7, 13, 13, 
                                 13, 11, 13, 11, 11, 11, 
                                 17, 11, 17, 17, 19, 
                                 13, 23, 23};

  unsigned int i, j, d, d2, dF;
  double dd2, jf;

  /* Find the smallest d so that the required number of blocks to cover
     a stage 2 interval of length B2-B2min is no greater than the given k, 
     or no greater than 9 if *k == 0 */
  for (i = 0; i < Npo2; i++)
    {
      d = l[i];
      d2 = l2[i];
      j = phi (d) / 2;
      for (dF = 1; dF < j; dF <<= 1); /* dF = 2^ceil(log_2(phi(d))) */
      dd2 = (double) d * (double) d2;
      jf = ceil ((B2 + dd2 - 5) / dd2) - floor (B2min / dd2);
      j = ceil (jf * (double) phi (d2) / (double) dF); 
      if (j <= *k || (*k == 0 && j <= 9))
        break;
    }

  if (i == Npo2)
    {
      fprintf (ECM_STDERR, "Error, too large step 2 bound, increase -k\n");
      return 1;
    }
  
  /* If the user specified a number of blocks, we'll use that no matter what.
     Since j may be smaller than k, this may increase the B2 limit */
  if (*k == 0)
    *k = j;
  *finald = d;
  *finald2 = d2;

  return 0;
}
