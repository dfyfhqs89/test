ToDo's:
- fix problem found by SleepHound <sleephound@yahoo.com> for
  ./ecm -sigma 1404040793 -power 2 5e4 11757135 < c3456
  where c3456 is the remaining composite from 2^22176+1
	[non-algebraic factors: 177409, 27320833]
- with -resume, print %time for THIS RUN instead of total run?
	[suggested by SleepHound <sleephound@yahoo.com>]
- use mpres in step 2
- Add a -qq switch that is "really" screen IO quiet (no stderr printing, etc).
  This would be for the ECM C/S project.
- write a real documentation (which format? texi can generate dvi and
  html,	or LaTeX can also generate dvi, pdf and html)
- document how to use the ecm(), pm1(), pp1() functions from a C program
  (may need changes to give parameters or options)
- add a configure file (check if alloca.h is needed, cf FreeBSD)
- implement Brent-Suyama's extension for p+1 (how to do it efficiently?
  Could "Powers of 2^(k/2) and 3^k", Montgomery dissertation, 5.5, work?)
- get rid of NTL for polygcd, and allow runtime choice between polyeval/polygcd
- add -fft option for 2^n+1 (in particular Fermat numbers)
- optimize memory usage in step 2 (use an unique array for multiplies)
- option -kill when user on console?
- compute probability that a factor of a certain size will be found with
  given paramters (Dickman's function, how to do it for P+/-1 ?)
- need sigma >= 5 for ECM?
- when resuming, print the *initial* x0 for P-1/P+1?
- option -base2 to force base2 when res/lo > threshold?
- extend maximal B1 in P+1 and ECM
- check number of multiplies in step 2, compute it for step 1
- get rid of __gmp_free_func (no longer declared in gmp.h)
- fix efficiency problem with P-1 (default is slower than -mpzmod for B1=1e7)
- for some values of len, toomcook3 should use toomcook4 for the
  recursive calls (for example len=26, where for len'=8, tc4 uses only
  21 multiplies instead of 23)
  -> PZ: tried but it slows things for "small" numbers (e.g. c155),
  where karatsuba is faster than toomcook4 for n=4, despite 9 muls
  instead of 7.
  It would be better to determine dynamically the best method to use
  depending on the input number size.  
- write a mpn version of add3 and duplicate  
- use/implement a mpn_mul_hi_n routine for use in mpn_REDC
- use mpn_addmul_2, mpn_addmul_4 in the basecase REDC [for machines
  where it exists]
- add a modular trial factoring mode (this was done in OpenPFGW). This is highly useful
  for certain types of searches where factors can only be of a certain modular form
  (Mersenne and Fermats are idea for this type of trial factoring).
- try McLaughlin's algorithm for Montgomery's modular multiplication
  (http://www.ams.org/mcom/0000-000-00/S0025-5718-03-01543-6/home.html)
- consider Colin Percival's generalized DWT for multiplication modulo
  k*a^n+b, where k*a*b is highly composite. May belong into GMP rather than
  gmp-ecm.

Partially Done's:
* print progress (80 dots in step 1/2) [Jay Berg]
  All done except for stage 2.
* option -nice ? -kill when user on console?
* partial saves during step 1 (Jay)?  (Added but not yet working, Jim)

Done's:
+ option -nice when user on console?
+ parser for input number in symbolic form, i.e. (2^(2^12)/(7*2^14+1)...)
  (Jay Berg)  (There is still more functions to add, but the parser is done)
+ changed the "default" search mode to -deep (continues to find factors after the 
  first factor is found).
+ added a new -one mode, that quits searching a canidate as soon as a factor is found.
+ created a -ve n to "verbosely" output expressions less than n chars long each time
  a loop is performed.
+ added a trial div mode (run on the first loop prior to running ECM, P+1, P-1 code)
  the syntax is -t n where trial division is done up to n
+ implement file input modes (other than < file redirection).  Added
  -i file (-i is breadth-first by default, stdin redirection is depth-first by
  default)
+ added -b to allow breadth-first processing of a stdin redirection or file input
+ added -d to allow depth-first processing of input files
+ added -i n for B1 adjustment (auto incrementation of B1 during looping)
+ added -I f for auto B1 adjustment (calculated and multiplied by the f constant), 
  This version computes the "optimal" B1 adjustment (depends upon current size of B1).
  There is then a "scaling" factor argument (f) that is multiplied by this computed
  value.  So -I 1 would be the "ideal", -I 10 would be 10x the ideal (to allow
  running the same number on 10 CPU's in parallel), a -I .25 would be 1/4 of ideal
  (if someone thinks the ideal is too much incrementation).  These "ideals" were
  created by looking at the "table of expected curves", and computing how much to
  "adjust B1" to get it to the next level with the "ideal" expected curves being
  run.  One range is 30 curves at B1=2000 and the next range starts at B1=11000.
  So there is a B1 range of 9000 for 30 curves, and we compute the "Optimal" B1
  increment at 300.
+ change [j*d, i] in stage2 with gcd(i,d)=1, i=1 mod 6
  to [j*d+1, i] with gcd(i+1,d)=1, i=0 mod 6 ?
  (Avoids i0=0 or 1 i.e. d + d -> 2d, or i0=0, i.e. 0 + d -> d, d + d -> 2d.)
  Not neccessary anymore as ECM now handles the neutral element in stage 2.
