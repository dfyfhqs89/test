- implement semi-normalized residues in mpmod.c: instead of ensuring
  0 <= r < n, just require limbs(r) <= limbs(n)
- use mpres in step 2
- print progress (80 dots in step 1/2) [Jay Berg]  (NOTE this may be
  difficult to do with the new 1 line output mode already using stderr,
  however I do have some ideas on how to do this, JimF).
  Here are my "ideas" on this:
    1.  This should not be done for "smaller" numbers, and/or where B1/B2
        is "small".  It should only be done based upon B1 stage and or B2
        stage taking more than some amount of time (30 seconds??)
    2.  There can be a "small" addition before the current stderr line.
        This would allow for T:000 to T:100, 1:000 to 1:100 and 2:000
        to 2:100.  The 000 to 100 being "percentage of done".  There
        would also be a space between the 000 to 100 and the Line=%d ...
        of the existing stderr printout.  The T:### would be trial factoring
        (if there was any trial factoring, and if it takes too long), the
        1:### is stage 1, and the 2:### is stage 2.
    3.  Now, within "trial", Phase 1, and Phase 2, at certain "key" times,
        the percentage would update.  I would suggest that we do up update
        the screen any more frequently than 30 seconds.  With Trial div, and
        stage 1, we should probably only check time every couple of thousand
        loops.  Stage 2 has some good "looping" checks in it already, and
        I think timing checks should be done there, and the percentages
        only updated at those times.
    4.  Currently, some code in main.c is done (adjusting of the current
        stderr Line=%d ... code (shoved it over right 6 spaces), and some
        "prelim" setting to T:000 and 1:000 and 2:100 are done to stderr.
        Also, Trial division is done, and can be seen as a "model" of what
        we can do with the other (stage 1 and stage 2) blocks of run-time.
- write a real documentation (which format? texi can generate dvi and
  html,	or LaTeX can also generate dvi, pdf and html)
- document how to use the ecm(), pm1(), pp1() functions from a C program
  (may need changes to give parameters or options)
- add a configure file (check if alloca.h is needed, cf FreeBSD)
- tune stage 2 values of 'd' to optimize toomcook4(d)/(d*phi(d/2)):
  for each value of d, compute k = ceil(B2/(d*phi(d)/2), then
  compute cost(d,k) = (k+1)*PolyFromRoots(dF)+PolyInvert(dF-1)+(k-1)*toomcook4(dF)
  +(k-1)*Reduce(dF)+polyeval(dF) where dF=Phi(d)/2
- implement Brent-Suyama's extension for p+1 (how to do it efficiently?
  Could "Powers of 2^(k/2) and 3^k", Montgomery dissertation, 5.5, work?)
- get rid of NTL for polygcd, and allow runtime choice between polyeval/polygcd
- change [j*d, i] in stage2 with gcd(i,d)=1, i=1 mod 6
  to [j*d+1, i] with gcd(i+1,d)=1, i=0 mod 6 ?
  (Avoids i0=0 or 1 i.e. d + d -> 2d, or i0=0, i.e. 0 + d -> d, d + d -> 2d.)
- add -fft option for 2^n+1 (in particular Fermat numbers)
* option -nice ? -kill when user on console?
- optimize memory usage in step 2 (use an unique array for multiplies)
+ parser for input number in symbolic form, i.e. (2^(2^12)/(7*2^14+1)...)
  (Jay Berg)  (There is still more functions to add, but the parser is done)
- compute probability that a factor of a certain size will be found with
  given paramters (Dickman's function, how to do it for P+/-1 ?)
- partial saves during step 1 (Jay)?
- need sigma >= 5 for ECM?
- when resuming, print the *initial* x0 for P-1/P+1?
- option -base2 to force base2 when res/lo > threshold?
- extend maximal B1 in P+1 and ECM
- check number of multiplies in step 2, compute it for step 1
- get rid of __gmp_free_func (no longer declared in gmp.h)
- implement high/low products in step 2
- fix efficiency problem with P-1 (default is slower than -mpzmod for B1=1e7)
- for some values of len, toomcook3 shoud use toomcook4 for the
  recursive calls (for example len=26, where for len'=8, tc4 uses only
  21 multiplies instead of 23)
- write a mpn version of add3 and duplicate  
- use/implement a mpn_mul_hi_n routine for use in mpn_REDC
- use mpn_addmul_2, mpn_addmul_4 in the basecase REDC [for machines
  where it exists]

Key:
- ToDo's
* Partial Todo (partly done, or work started)
+ Done's
